<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Charles Grassi | Graphics Programmer & Technical Artist</title>
    <link rel="icon" type="image/png" id="favicon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABISURBVFhH7c0xAQAgDMCwgX/PYAdxdkGxSPquzj47AAAAAAAAAADABw+wAAuwAAuwAAuwAAuwAAuwAAuwAAuwAAuwAAsw1HUBKABKOl4R5FAAAAAASUVORK5CYII=">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg-primary: #0a0f14;
            --bg-secondary: #111921;
            --bg-card: #151d26;
            --accent-gold: #e8b923;
            --accent-gold-dim: #c49a1a;
            --accent-teal: #2dd4bf;
            --text-primary: #e8eaed;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --border-color: #1f2937;
            --gradient-mesh: radial-gradient(ellipse 120% 100% at 20% 0%, rgba(232, 185, 35, 0.05) 0%, rgba(232, 185, 35, 0.02) 30%, transparent 70%), radial-gradient(ellipse 100% 80% at 80% 100%, rgba(45, 212, 191, 0.03) 0%, rgba(45, 212, 191, 0.01) 30%, transparent 70%);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        #gpu-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .contact-btn {
            position: fixed;
            top: 2rem;
            right: 2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.7rem 1.4rem;
            background: rgba(232, 185, 35, 0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(232, 185, 35, 0.4);
            border-radius: 50px;
            color: var(--accent-gold);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 500;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            box-shadow: 0 0 20px rgba(232, 185, 35, 0.1), inset 0 0 20px rgba(232, 185, 35, 0.05);
        }

            .contact-btn:hover {
                background: rgba(232, 185, 35, 0.25);
                border-color: var(--accent-gold);
                box-shadow: 0 0 30px rgba(232, 185, 35, 0.3), inset 0 0 20px rgba(232, 185, 35, 0.1);
                transform: translateY(-1px);
            }

            .contact-btn:active {
                transform: translateY(0) scale(0.98);
            }

            .contact-btn svg {
                width: 14px;
                height: 14px;
                opacity: 0.9;
            }

        @media print {
            .contact-btn {
                display: none !important;
            }
        }

        @media (max-width: 900px) {
            .contact-btn {
                top: 1rem;
                right: 1rem;
                padding: 0.6rem 1rem;
                font-size: 0.75rem;
            }
        }

        .noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.03;
            z-index: 1000;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* FPS Performance Badge */
        .fps-badge {
            position: fixed;
            bottom: 1.5rem;
            left: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: rgba(21, 29, 38, 0.85);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            z-index: 100;
            transition: all 0.3s ease;
            cursor: default;
            user-select: none;
        }

        .fps-badge:hover {
            border-color: var(--accent-teal);
            color: var(--text-secondary);
        }

        .fps-badge .fps-icon {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-teal);
            box-shadow: 0 0 6px rgba(45, 212, 191, 0.5);
            animation: fpsPulse 2s ease-in-out infinite;
        }

        .fps-badge.good .fps-icon {
            background: var(--accent-teal);
            box-shadow: 0 0 6px rgba(45, 212, 191, 0.5);
        }

        .fps-badge.warn .fps-icon {
            background: var(--accent-gold);
            box-shadow: 0 0 6px rgba(232, 185, 35, 0.5);
        }

        .fps-badge.bad .fps-icon {
            background: #ef4444;
            box-shadow: 0 0 6px rgba(239, 68, 68, 0.5);
        }

        @keyframes fpsPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.9); }
        }

        .fps-badge .fps-value {
            font-weight: 600;
            color: var(--accent-teal);
            min-width: 2ch;
            text-align: right;
        }

        .fps-badge.warn .fps-value {
            color: var(--accent-gold);
        }

        .fps-badge.bad .fps-value {
            color: #ef4444;
        }

        .fps-badge .fps-label {
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        @media (max-width: 900px) {
            .fps-badge {
                bottom: 1rem;
                left: 1rem;
                padding: 0.4rem 0.6rem;
                font-size: 0.6rem;
            }
        }

        @media print {
            .fps-badge {
                display: none !important;
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem 2rem 1.5rem;
            background: transparent;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

            .container::before {
                content: '';
                position: absolute;
                top: 0;
                left: 50%;
                transform: translateX(-50%);
                width: 100vw;
                height: 100%;
                background: radial-gradient(ellipse 120% 100% at 20% 0%, rgba(232, 185, 35, 0.05) 0%, rgba(232, 185, 35, 0.02) 30%, transparent 70%), radial-gradient(ellipse 100% 80% at 80% 50%, rgba(45, 212, 191, 0.03) 0%, rgba(45, 212, 191, 0.01) 30%, transparent 70%);
                pointer-events: none;
                z-index: -1;
            }

        /* Header */
        header {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 1.5rem;
            padding-bottom: 0.6rem;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.6rem;
            animation: fadeInUp 0.6s ease-out;
            flex-shrink: 0;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .name-block h1 {
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: -0.03em;
            line-height: 1;
            margin-bottom: 0.2rem;
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-gold-dim) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tagline {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.2rem;
            font-weight: 300;
        }

        .titles {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-top: 0.4rem;
        }

        .title-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 500;
            padding: 0.3rem 0.6rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

            .title-tag.highlight {
                border-color: var(--accent-gold);
                color: var(--accent-gold);
            }

        .contact-block {
            text-align: right;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

            .contact-block a {
                color: var(--text-secondary);
                text-decoration: none;
                display: block;
                padding: 0.15rem 0;
                transition: color 0.2s ease;
            }

                .contact-block a:hover {
                    color: var(--accent-teal);
                }

            .contact-block .company {
                color: var(--accent-gold);
                font-weight: 500;
                margin-bottom: 0.2rem;
            }

        .languages {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
            justify-content: flex-start;
        }

        .lang {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-muted);
        }

        /* Reveal Animations */
        @keyframes skillReveal {
            0% {
                opacity: 0;
                transform: scale(0.8);
                filter: brightness(1);
                box-shadow: none;
            }
            50% {
                filter: brightness(1.8);
                box-shadow: 0 0 20px rgba(45, 212, 191, 0.6);
            }
            100% {
                opacity: 1;
                transform: scale(1);
                filter: brightness(1);
                box-shadow: none;
            }
        }

        @keyframes skillRevealGold {
            0% {
                opacity: 0;
                transform: scale(0.8);
                filter: brightness(1);
                box-shadow: none;
            }
            50% {
                filter: brightness(2);
                box-shadow: 0 0 25px rgba(232, 185, 35, 0.7);
            }
            100% {
                opacity: 1;
                transform: scale(1);
                filter: brightness(1);
                box-shadow: none;
            }
        }

        /* Summary Section with Stats */
        .summary-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 0.6rem;
            align-items: stretch;
            flex-shrink: 0;
        }

        .summary {
            flex: 1;
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.5) 0%, rgba(21, 29, 38, 0.2) 70%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
            padding: 1rem 1.25rem;
        }

        .stats-bar {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.25rem;
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.5) 0%, rgba(21, 29, 38, 0.2) 70%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
            animation: fadeInUp 0.6s ease-out 0.15s backwards;
        }

        .stat-item {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-gold);
            line-height: 1;
            font-family: 'JetBrains Mono', monospace;
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

            .summary p {
                color: var(--text-secondary);
                font-size: 0.8rem;
                line-height: 1.6;
            }

            .summary .highlight-text {
                color: var(--accent-gold);
                font-weight: 500;
            }

        /* Typewriter effect */
        .typewriter-text {
            position: relative;
        }

        .typewriter-cursor {
            display: inline-block;
            width: 2px;
            height: 1.1em;
            background: var(--accent-gold);
            margin-left: 2px;
            vertical-align: text-bottom;
            animation: cursorBlink 0.6s infinite;
        }

        .typewriter-cursor.hidden {
            opacity: 0;
            animation: none;
        }

        @keyframes cursorBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .typo-char {
            color: var(--accent-teal);
            opacity: 0.7;
        }

        .typing-indicator {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            position: absolute;
            bottom: -1.5rem;
            left: 0;
            opacity: 0.6;
        }

        .typing-indicator.hidden {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .summary {
            position: relative;
        }

        .typing-dots {
            display: inline;
        }

        .typing-dots span {
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .typing-dots span.visible {
            opacity: 1;
        }

        /* Project List - Timeline Style */
        .project-list-wrapper {
            position: relative;
            overflow: hidden;
            flex: 1;
        }

        .project-list {
            display: flex;
            flex-direction: column;
            gap: 0;
            height: 100%;
            overflow-y: auto;
            padding-right: 0.5rem;
            scroll-behavior: smooth;
        }

        /* Custom scrollbar */
        .project-list::-webkit-scrollbar {
            width: 3px;
        }

        .project-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .project-list::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 2px;
        }

        .project-list::-webkit-scrollbar-thumb:hover {
            background: var(--accent-gold);
        }

        /* Fade hints at top and bottom */
        .project-list-wrapper::before,
        .project-list-wrapper::after {
            content: '';
            position: absolute;
            left: 0;
            right: 8px;
            height: 40px;
            pointer-events: none;
            z-index: 2;
            transition: opacity 0.3s ease;
        }

        .project-list-wrapper::before {
            top: 0;
            background: linear-gradient(to bottom, var(--bg-primary), transparent);
            opacity: 0;
        }

        .project-list-wrapper::after {
            bottom: 0;
            background: linear-gradient(to top, var(--bg-primary), transparent);
            opacity: 1;
        }

        .project-list-wrapper.scrolled-top::before {
            opacity: 0;
        }

        .project-list-wrapper.scrolled-middle::before,
        .project-list-wrapper.scrolled-middle::after {
            opacity: 1;
        }

        .project-list-wrapper.scrolled-end::after {
            opacity: 0;
        }

        .project-card {
            position: relative;
            padding: 0.85rem 0 0.85rem 1rem;
            background: transparent;
            border: none;
            border-left: 2px solid var(--border-color);
            margin-left: 0.5rem;
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateX(-10px);
            animation: projectReveal 0.5s ease forwards;
        }

        .project-card::before {
            content: '';
            position: absolute;
            left: -5px;
            top: 1.1rem;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border-color);
            border: 2px solid var(--bg-primary);
            transition: all 0.3s ease;
        }

        @keyframes projectReveal {
            0% {
                opacity: 0;
                transform: translateX(-10px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .project-card:hover {
            border-left-color: var(--accent-gold);
        }

        .project-card:hover::before {
            background: var(--accent-gold);
            box-shadow: 0 0 10px rgba(232, 185, 35, 0.5);
        }

        .project-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.3rem;
            gap: 0.5rem;
        }

        .project-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            line-height: 1.3;
        }

        .project-client {
            font-size: 0.75rem;
            color: var(--accent-teal);
            font-weight: 500;
        }

        .project-year {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .project-desc {
            color: var(--text-secondary);
            font-size: 0.75rem;
            line-height: 1.5;
            margin-top: 0.25rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .project-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-top: 0.4rem;
        }

        .tech-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.55rem;
            padding: 0.15rem 0.4rem;
            background: transparent;
            border: 1px solid var(--accent-teal);
            border-radius: 3px;
            color: var(--accent-teal);
            opacity: 0.8;
        }

        /* Leadership card highlight */
        .leadership-card {
            border-left-color: var(--accent-gold);
        }

        .leadership-card::before {
            background: var(--accent-gold);
        }

        .leadership-card .project-title {
            color: var(--accent-gold);
        }

        .leadership-card .tech-tag {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        /* Scroll hint text */
        .scroll-hint {
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
            opacity: 0.5;
        }

        /* Tabbed Carousel Section */
        .tabbed-carousel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            animation: fadeInUp 0.6s ease-out 0.3s backwards;
        }

        .carousel-tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 0.6rem;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .carousel-tab {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 500;
            padding: 0.55rem 1.1rem;
            background: rgba(21, 29, 38, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 50px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            position: relative;
            overflow: hidden;
        }

        .carousel-tab::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .carousel-tab:hover {
            border-color: rgba(45, 212, 191, 0.4);
            color: var(--text-primary);
            background: rgba(45, 212, 191, 0.1);
        }

        .carousel-tab:hover::before {
            opacity: 1;
        }

        .carousel-tab.active {
            background: rgba(232, 185, 35, 0.2);
            border-color: rgba(232, 185, 35, 0.5);
            color: var(--accent-gold);
            font-weight: 600;
            box-shadow: 0 0 20px rgba(232, 185, 35, 0.15), inset 0 0 15px rgba(232, 185, 35, 0.05);
        }

        .carousel-tab.active::before {
            opacity: 1;
            background: linear-gradient(135deg, rgba(232, 185, 35, 0.15) 0%, transparent 50%);
        }

        .carousel-panels {
            position: relative;
            flex: 1;
            min-height: 0;
        }

        .carousel-panel {
            display: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            height: 100%;
        }

        .carousel-panel.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
            transform: translateY(0);
        }

        /* Skills Panel - Network Graph */
        .skills-panel .skill-graph-container {
            margin: 0;
            flex: 1;
            height: auto;
            background: transparent;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .skills-panel .graph-legend,
        .skills-panel .graph-hint {
            display: none;
        }

        /* Career Panel - Timeline */
        .career-panel {
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.4) 0%, rgba(21, 29, 38, 0.15) 60%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
            padding: 1.5rem;
        }

        .career-panel .project-list-wrapper {
            flex: 1;
            max-height: none;
        }

        .career-panel .project-list {
            max-height: 100%;
            height: 100%;
        }

        /* Clients Panel */
        .clients-panel {
            padding: 2rem;
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.4) 0%, rgba(21, 29, 38, 0.15) 60%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
        }

        .clients-panel.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .clients-panel .client-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 0.75rem;
            max-width: 750px;
            width: 100%;
        }

        .clients-panel .client-card {
            padding: 0.85rem 1.5rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 50px;
            text-align: center;
            text-decoration: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: translateY(15px);
            animation: clientFadeIn 0.6s ease forwards;
            position: relative;
        }

        .clients-panel .client-card:nth-child(1) { animation-delay: 0s; }
        .clients-panel .client-card:nth-child(2) { animation-delay: 0.05s; }
        .clients-panel .client-card:nth-child(3) { animation-delay: 0.1s; }
        .clients-panel .client-card:nth-child(4) { animation-delay: 0.15s; }
        .clients-panel .client-card:nth-child(5) { animation-delay: 0.2s; }
        .clients-panel .client-card:nth-child(6) { animation-delay: 0.25s; }
        .clients-panel .client-card:nth-child(7) { animation-delay: 0.3s; }
        .clients-panel .client-card:nth-child(8) { animation-delay: 0.35s; }
        .clients-panel .client-card:nth-child(9) { animation-delay: 0.4s; }
        .clients-panel .client-card:nth-child(10) { animation-delay: 0.45s; }
        .clients-panel .client-card:nth-child(11) { animation-delay: 0.5s; }
        .clients-panel .client-card:nth-child(12) { animation-delay: 0.55s; }

        @keyframes clientFadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .clients-panel .client-card:hover {
            border-color: var(--accent-gold);
            background: rgba(232, 185, 35, 0.12);
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(232, 185, 35, 0.2);
        }

        .clients-panel .client-name {
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--text-secondary);
            transition: color 0.3s ease;
            white-space: nowrap;
        }

        .clients-panel .client-card:hover .client-name {
            color: var(--accent-gold);
        }

        /* Portfolio Panel */
        .portfolio-panel {
            padding: 1.5rem;
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.4) 0%, rgba(21, 29, 38, 0.15) 60%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
            overflow: hidden;
        }

        .portfolio-panel.active {
            display: flex;
            flex-direction: column;
        }

        .portfolio-carousel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
            padding: 0.5rem 0;
            animation: portfolioFadeIn 0.8s ease-out;
        }

        @keyframes portfolioFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .portfolio-header {
            text-align: center;
            margin-bottom: 0.75rem;
            flex-shrink: 0;
        }

        .portfolio-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .portfolio-link {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--accent-teal);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .portfolio-link:hover {
            color: var(--accent-gold);
        }

        .portfolio-scene {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 1200px;
            overflow: visible;
        }

        .portfolio-track {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .portfolio-item {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 55%;
            max-width: 500px;
            aspect-ratio: 16/10;
            transform-style: preserve-3d;
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .portfolio-item img,
        .portfolio-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 10px;
            transition: transform 0.3s ease;
        }

        .portfolio-item.active {
            z-index: 10;
            cursor: pointer;
        }

        .portfolio-item.active:hover img,
        .portfolio-item.active:hover video {
            transform: scale(1.02);
        }

        .portfolio-item::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, transparent 60%, rgba(0,0,0,0.4) 100%);
            border-radius: 10px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .portfolio-item:not(.active)::after {
            opacity: 1;
            background: rgba(0, 0, 0, 0.4);
        }

        .portfolio-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 44px;
            height: 44px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            background: rgba(21, 29, 38, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-secondary);
            z-index: 20;
        }

        .portfolio-nav:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(232, 185, 35, 0.15);
            transform: translateY(-50%) scale(1.1);
        }

        .portfolio-nav.prev {
            left: 1rem;
        }

        .portfolio-nav.next {
            right: 1rem;
        }

        .portfolio-nav svg {
            width: 20px;
            height: 20px;
        }

        .portfolio-dots {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-shrink: 0;
        }

        .portfolio-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border-color);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .portfolio-dot:hover {
            background: var(--text-muted);
        }

        .portfolio-dot.active {
            background: var(--accent-gold);
            box-shadow: 0 0 10px rgba(232, 185, 35, 0.5);
        }

        /* Testimonials Panel */
        .testimonials-panel {
            padding: 1.5rem;
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.4) 0%, rgba(21, 29, 38, 0.15) 60%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
            overflow-y: auto;
            gap: 1rem;
        }

        .testimonials-panel.active {
            display: flex;
            flex-direction: column;
        }

        .testimonial-card {
            padding: 1.5rem;
            background: linear-gradient(135deg, var(--bg-card) 0%, rgba(232, 185, 35, 0.03) 100%);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            position: relative;
            opacity: 0;
            transform: translateX(-10px);
            animation: projectReveal 0.5s ease forwards;
        }

        .testimonial-card::before {
            content: '"';
            position: absolute;
            top: 0.5rem;
            left: 1rem;
            font-size: 3rem;
            font-family: Georgia, serif;
            color: var(--accent-gold);
            opacity: 0.3;
            line-height: 1;
        }

        .testimonial-quote {
            font-size: 0.95rem;
            color: var(--text-secondary);
            line-height: 1.7;
            font-style: italic;
            margin-bottom: 1rem;
            padding-left: 1.5rem;
        }

        .testimonial-author {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding-left: 1.5rem;
        }

        .testimonial-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-teal) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.8rem;
            color: var(--bg-primary);
        }

        .testimonial-info {
            display: flex;
            flex-direction: column;
        }

        .testimonial-name {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .testimonial-role {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        /* Skill Graph */
        .skill-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 250px;
            background: rgba(21, 29, 38, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
            cursor: grab;
        }

        .skill-graph-container:active {
            cursor: grabbing;
        }

        #skill-graph-canvas {
            width: 100%;
            height: 100%;
        }

        .graph-legend {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            display: flex;
            gap: 1.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .legend-dot.primary { background: var(--accent-gold); }
        .legend-dot.secondary { background: var(--accent-teal); }
        .legend-dot.tool { background: var(--text-muted); }

        .graph-hint {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
            opacity: 0.7;
        }

        .skill-tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(21, 29, 38, 0.95);
            border: 1px solid var(--accent-teal);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            width: 260px;
            opacity: 0;
            transition: opacity 0.25s ease;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .skill-tooltip.visible {
            opacity: 1;
        }

        .skill-tooltip.primary {
            border-color: var(--accent-gold);
        }

        .skill-tooltip.tool {
            border-color: var(--text-muted);
        }

        .skill-tooltip-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-gold);
            margin-bottom: 0.25rem;
        }

        .skill-tooltip.secondary .skill-tooltip-title {
            color: var(--accent-teal);
        }

        .skill-tooltip.tool .skill-tooltip-title {
            color: var(--text-secondary);
        }

        .skill-tooltip-desc {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .skill-tooltip-usage {
            font-size: 0.7rem;
            color: var(--text-muted);
            line-height: 1.5;
            border-top: 1px solid var(--border-color);
            padding-top: 0.5rem;
        }

        @media (max-width: 900px) {
            .skill-graph-container {
                height: 320px;
            }
        }

        /* Footer - Hidden for 100vh layout */
        footer {
            display: none;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 1rem;
        }

            .footer-links a {
                font-family: 'JetBrains Mono', monospace;
                font-size: 0.8rem;
                color: var(--text-muted);
                text-decoration: none;
                transition: color 0.2s ease;
            }

                .footer-links a:hover {
                    color: var(--accent-teal);
                }

        .footer-note {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 900px) {
            .container {
                padding: 1rem;
                height: auto;
                min-height: 100vh;
            }

            header {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .contact-block {
                text-align: left;
            }

            .languages {
                justify-content: flex-start;
            }

            .name-block h1 {
                font-size: 2rem;
            }

            .summary-row {
                flex-direction: column;
                gap: 1rem;
            }

            .stats-bar {
                flex-direction: row;
                justify-content: center;
                gap: 2rem;
                padding: 0.75rem 1.5rem;
            }

            .carousel-tabs {
                gap: 0.35rem;
            }

            .carousel-tab {
                padding: 0.5rem 0.8rem;
                font-size: 0.65rem;
            }

            .clients-panel {
                padding: 1.25rem;
            }

            .clients-panel .client-grid {
                gap: 0.5rem;
            }

            .clients-panel .client-card {
                padding: 0.6rem 1rem;
            }

            .clients-panel .client-name {
                font-size: 0.8rem;
            }

            /* Portfolio mobile improvements */
            .portfolio-panel {
                padding: 1rem;
            }

            .portfolio-header {
                margin-bottom: 0.5rem;
            }

            .portfolio-title {
                font-size: 0.85rem;
                line-height: 1.3;
                padding: 0 2.5rem;
            }

            .portfolio-link {
                font-size: 0.6rem;
            }

            .portfolio-scene {
                perspective: 800px;
            }

            .portfolio-item {
                width: 75%;
                max-width: none;
                border-radius: 8px;
            }

            .portfolio-item img,
            .portfolio-item video {
                border-radius: 8px;
            }

            /* Larger touch targets for nav buttons */
            .portfolio-nav {
                width: 48px;
                height: 48px;
                min-width: 48px;
                min-height: 48px;
            }

            .portfolio-nav.prev {
                left: 0.25rem;
            }

            .portfolio-nav.next {
                right: 0.25rem;
            }

            .portfolio-nav svg {
                width: 24px;
                height: 24px;
            }

            .portfolio-dots {
                gap: 0.4rem;
                margin-top: 0.75rem;
                flex-wrap: wrap;
                max-width: 100%;
                padding: 0 1rem;
            }

            .portfolio-dot {
                width: 6px;
                height: 6px;
            }

        }

        /* Extra small screens */
        @media (max-width: 480px) {
            .portfolio-item {
                width: 85%;
            }

            .portfolio-nav {
                width: 40px;
                height: 40px;
                min-width: 40px;
                min-height: 40px;
            }

            .portfolio-nav.prev {
                left: 0.15rem;
            }

            .portfolio-nav.next {
                right: 0.15rem;
            }

            .portfolio-title {
                font-size: 0.75rem;
                padding: 0 2rem;
            }

            .carousel-tab {
                padding: 0.4rem 0.6rem;
                font-size: 0.6rem;
            }
        }

        @media print {
            #gpu-canvas {
                display: none;
            }

            .noise-overlay {
                display: none;
            }

            body {
                background: white;
                color: #1a1a1a;
            }

            .container {
                padding: 1rem;
            }

            .project-card {
                break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <canvas id="gpu-canvas"></canvas>
    <div class="noise-overlay"></div>

    <!-- FPS Performance Badge -->
    <div class="fps-badge good" id="fps-badge" title="Real-time performance metrics">
        <span class="fps-icon"></span>
        <span class="fps-value" id="fps-value">60</span>
        <span class="fps-label">FPS</span>
    </div>

    <a href="mailto:contact.charles.grassi@gmail.com" class="contact-btn">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
        </svg>
        Contact Me
    </a>
    <div class="container">
        <header>
            <div class="name-block">
                <h1>Charles Grassi</h1>
                <div class="titles">
                    <span class="title-tag highlight">Shader Specialist</span>
                    <span class="title-tag highlight">Technical Artist</span>
                    <span class="title-tag">Graphics Engineer</span>
                    <span class="title-tag">C# Developer</span>
                </div>
                <div class="languages">
                    <span class="lang">EN</span>
                    <span class="lang">FR</span>
                </div>
            </div>
            <div class="contact-block">
                <div class="company">Zylaris Ltd Â· Cyprus</div>
                <a href="mailto:contact.charles.grassi@gmail.com">contact.charles.grassi@gmail.com</a>
                <a href="tel:+33646118214">(+33) 6 46 11 82 14</a>
                <a href="https://twitter.com/charles_grassi" target="_blank">@charles_grassi</a>
                <a href="https://www.linkedin.com/in/charles-grassi/" target="_blank">LinkedIn</a>
            </div>
        </header>

        <!-- Summary + Stats Row -->
        <div class="summary-row">
            <div class="summary">
                <p class="typewriter-text" id="typewriter-container"></p>
                <div class="typing-indicator" id="typing-indicator">Charles is typing<span class="typing-dots"><span>.</span><span>.</span><span>.</span></span></div>
            </div>
            <div class="stats-bar">
                <div class="stat-item">
                    <div class="stat-number" id="stat-years" data-target="7" data-suffix="+">0</div>
                    <div class="stat-label">Years Exp.</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="stat-studios" data-target="12" data-suffix="+">0</div>
                    <div class="stat-label">Studios</div>
                </div>
            </div>
        </div>

        <!-- Tabbed Carousel -->
        <section class="tabbed-carousel">
            <div class="carousel-tabs">
                <button class="carousel-tab active" data-panel="skills">Skills</button>
                <button class="carousel-tab" data-panel="portfolio">Portfolio</button>
                <button class="carousel-tab" data-panel="career">Career</button>
                <button class="carousel-tab" data-panel="clients">Clients</button>
                <button class="carousel-tab" data-panel="testimonials">Testimonials</button>
            </div>

            <div class="carousel-panels">
                <!-- Skills Panel - Network Graph -->
                <div class="carousel-panel skills-panel active" id="panel-skills">
                    <div class="skill-graph-container">
                        <canvas id="skill-graph-canvas"></canvas>
                        <div class="skill-tooltip" id="skill-tooltip">
                            <div class="skill-tooltip-title"></div>
                            <div class="skill-tooltip-desc"></div>
                            <div class="skill-tooltip-usage"></div>
                        </div>
                        <div class="graph-legend">
                            <div class="legend-item">
                                <span class="legend-dot primary"></span>
                                <span>Core Skills</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-dot secondary"></span>
                                <span>Secondary</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-dot tool"></span>
                                <span>Tools</span>
                            </div>
                        </div>
                        <div class="graph-hint">Drag nodes to explore</div>
                    </div>
                </div>

                <!-- Portfolio Panel - 3D Curved Carousel -->
                <div class="carousel-panel portfolio-panel" id="panel-portfolio">
                    <div class="portfolio-carousel">
                        <div class="portfolio-header">
                            <div class="portfolio-title" id="portfolio-title">Blumhouse Enhanced Cinema - Nexus Studio</div>
                            <a href="" target="_blank" class="portfolio-link" id="portfolio-link" style="display: none;">View on ArtStation</a>
                        </div>
                        <div class="portfolio-scene">
                            <button class="portfolio-nav prev" aria-label="Previous">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
                            </button>
                            <button class="portfolio-nav next" aria-label="Next">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
                            </button>
                            <div class="portfolio-track" id="portfolio-track">
                                <div class="portfolio-item" data-index="0" data-title="Blumhouse Enhanced Cinema - Nexus Studio" data-url="">
                                    <img src="https://scontent-mad1-1.oculuscdn.com/v/t64.5771-25/491820855_1330335225127412_3510880302341334513_n.webp?stp=dst-webp_s1440x1440&_nc_cat=102&ccb=1-7&_nc_sid=6e7a0a&_nc_ohc=jwaHnWVg7NAQ7kNvwFFSFiQ&_nc_oc=Adnl6kOUV3vSINwS7ZNYAAt56PdBcTgpZZdDMhcxLrkPTZ1KSHNTZuv-WyvLGabMSEg&_nc_zt=3&_nc_ht=scontent-mad1-1.oculuscdn.com&oh=00_Afk6_PCtYpRQNGym1aFIWwlW1aIZgJSfSRW8Y-tCCqQtLQ&oe=694E49C6" alt="Blumhouse Enhanced Cinema - Nexus Studio">
                                </div>
                                <div class="portfolio-item" data-index="1" data-title="Blumhouse Enhanced Cinema - Nexus Studio" data-url="">
                                    <img src="https://scontent-mad2-1.oculuscdn.com/v/t64.5771-25/491818938_683528594784504_5440229394557734527_n.webp?stp=dst-webp_s1440x1440&_nc_cat=104&ccb=1-7&_nc_sid=6e7a0a&_nc_ohc=wm6Kr92OVIsQ7kNvwGPjwum&_nc_oc=AdlhPx0vcVBCXKZh2X_XudgsSOqa1W6mWZJAP7R5aZVM1iZTKgUHrcXPg3IKzMEv7q8&_nc_zt=3&_nc_ht=scontent-mad2-1.oculuscdn.com&oh=00_AflKWVO2pimeWortG7zmjf6Nnz4hRXR5ARPp9MC_u2_rIg&oe=694E5A96" alt="Blumhouse Enhanced Cinema - Nexus Studio">
                                </div>
                                <div class="portfolio-item" data-index="2" data-title="Cave 360Â° Scene Composition" data-url="https://www.artstation.com/artwork/V216yN">
                                    <img src="https://cdna.artstation.com/p/assets/images/images/084/284/470/large/charles-grassi-screenshot-2025-01-11-181036-2.jpg" alt="Cave 360Â° Scene Composition">
                                </div>
                                <div class="portfolio-item" data-index="3" data-title="Volumetric Fog | Cloud With Rain & Thunder" data-url="https://www.artstation.com/artwork/V216JZ">
                                    <img src="https://cdna.artstation.com/p/assets/images/images/084/274/870/large/charles-grassi-screenshot-2024-10-08-064527.jpg" alt="Volumetric Fog | Cloud With Rain & Thunder">
                                </div>
                                <div class="portfolio-item" data-index="4" data-title="Maelstrom - Unreal Engine" data-url="https://www.artstation.com/artwork/WXKB2E">
                                    <video src="https://cdn.artstation.com/p/video_sources/002/151/772/out-3.mp4" poster="https://cdnb.artstation.com/p/assets/images/images/079/164/965/large/charles-grassi-screenshot-2024-08-15-031337.jpg" autoplay muted loop playsinline preload="metadata"></video>
                                </div>
                                <div class="portfolio-item" data-index="5" data-title="Cartoon Ocean Shader & Breakdown" data-url="https://www.artstation.com/artwork/x3AvG2">
                                    <img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/424/977/large/charles-grassi-thumb.jpg" alt="Cartoon Ocean Shader">
                                </div>
                                <div class="portfolio-item" data-index="6" data-title="Raytraced Mountain Scene in a Single Shader" data-url="https://www.artstation.com/artwork/EzqE08">
                                    <img src="https://cdnb.artstation.com/p/assets/images/images/078/404/623/large/charles-grassi-screenshot-2024-03-06-030921.jpg" alt="Raytraced Mountain Scene">
                                </div>
                                <div class="portfolio-item" data-index="7" data-title="SABDA - Projection Mapping Immersive 360Â° Scenes" data-url="https://www.artstation.com/artwork/6LnRor">
                                    <img src="https://cdna.artstation.com/p/assets/images/images/078/403/874/large/charles-grassi-screenshot-2023-11-01-200540.jpg" alt="SABDA Projection Mapping">
                                </div>
                                <div class="portfolio-item" data-index="8" data-title="SABDA - Projection Mapping Immersive 360Â° Scenes" data-url="https://www.artstation.com/artwork/6LnRor">
                                    <img src="https://cdnb.artstation.com/p/assets/images/images/078/403/499/large/charles-grassi-copy-of-sabda-20240118-005.jpg" alt="SABDA Projection Mapping">
                                </div>
                                <div class="portfolio-item" data-index="9" data-title="SABDA - Projection Mapping Immersive 360Â° Scenes" data-url="https://www.artstation.com/artwork/6LnRor">
                                    <img src="https://cdnb.artstation.com/p/assets/images/images/078/435/209/large/charles-grassi-copy-of-sabda-20240118-010.jpg" alt="SABDA Projection Mapping">
                                </div>
                                <div class="portfolio-item" data-index="10" data-title="Multi-Threaded Space Colonization Algorithm" data-url="https://www.artstation.com/artwork/zxKvQw">
                                    <img src="https://cdnb.artstation.com/p/assets/images/images/084/275/951/large/charles-grassi-screenshot-2023-12-25-213543.jpg" alt="Space Colonization Algorithm">
                                </div>
                                <div class="portfolio-item" data-index="11" data-title="Alien Egg Shader" data-url="https://www.artstation.com/artwork/K36Por">
                                    <video src="https://cdn.artstation.com/p/video_sources/002/099/541/alienegg.mp4" poster="https://cdna.artstation.com/p/assets/images/images/078/403/954/large/charles-grassi-screenshot-2023-10-18-193823.jpg" autoplay muted loop playsinline preload="metadata"></video>
                                </div>
                                <div class="portfolio-item" data-index="12" data-title="Sandbox Stylized Cloud & God Rays Shader" data-url="https://www.artstation.com/artwork/nJwNLO">
                                    <img src="https://cdna.artstation.com/p/assets/images/images/078/429/084/large/charles-grassi-sandbox-stylized-cloud-night.jpg" alt="Sandbox Stylized Cloud Shaders">
                                </div>
                                <div class="portfolio-item" data-index="13" data-title="Oily Ocean Surface Shader" data-url="https://www.artstation.com/artwork/gRgVEK">
                                    <img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/425/435/large/charles-grassi-thumb.jpg" alt="Oily Ocean Surface Shader">
                                </div>
                                <div class="portfolio-item" data-index="14" data-title="Baked Volumetric Colored Fog" data-url="https://www.artstation.com/artwork/JraPGz">
                                    <img src="https://cdnb.artstation.com/p/assets/images/images/078/404/507/large/charles-grassi-screenshot-2023-03-27-145100.jpg" alt="Baked Volumetric Colored Fog">
                                </div>
                                <div class="portfolio-item" data-index="15" data-title="Single Draw Call Grass Shader" data-url="https://www.artstation.com/artwork/V2oaP4">
                                    <img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/425/261/large/charles-grassi-thumb.jpg" alt="Single Draw Call Grass Shader">
                                </div>
                                <div class="portfolio-item" data-index="16" data-title="CPU Multi-Threaded Burst Marching Cube Terrain" data-url="https://www.artstation.com/artwork/Ovqgby">
                                    <img src="https://cdna.artstation.com/p/assets/video_clips/images/078/425/098/large/charles-grassi-thumb.jpg" alt="Marching Cube Terrain">
                                </div>
                                <div class="portfolio-item" data-index="17" data-title="HDRP - Interior Lighting Scenarios" data-url="https://www.artstation.com/artwork/Bko5el">
                                    <img src="https://cdna.artstation.com/p/assets/images/images/078/519/226/large/charles-grassi-screenshot-2023-10-29-140203-2.jpg" alt="HDRP Interior Lighting">
                                </div>
                                <div class="portfolio-item" data-index="18" data-title="Orthographic Water Surface" data-url="https://www.artstation.com/artwork/wrAvRL">
                                    <img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/425/243/large/charles-grassi-thumb.jpg" alt="Orthographic Water Surface">
                                </div>
                            </div>
                        </div>
                        <div class="portfolio-dots" id="portfolio-dots"></div>
                    </div>
                </div>

                <!-- Career Panel - Timeline -->
                <div class="carousel-panel career-panel" id="panel-career">
                    <div class="project-list-wrapper" id="project-list-wrapper">
                        <div class="project-list" id="project-list">
                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Technical Artist & Graphics Programmer</div>
                                        <div class="project-client">Nexus Studios</div>
                                    </div>
                                    <div class="project-year">2025</div>
                                </div>
                                <div class="project-desc">
                                    Built a real-time global illumination system using SDF representations of scanned VR environments.
                                    Implemented GPU compute pipelines for efficient light transport calculations optimized for VR hardware constraints.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Compute Shaders</span>
                                    <span class="tech-tag">SDF</span>
                                    <span class="tech-tag">VR</span>
                                    <span class="tech-tag">Global Illumination</span>
                                </div>
                            </article>

                            <article class="project-card leadership-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Chief Technology Officer</div>
                                        <div class="project-client">SABDA</div>
                                    </div>
                                    <div class="project-year">2023â2024</div>
                                </div>
                                <div class="project-desc">
                                    Led technical direction for a large-scale 16K immersive installation. Developed real-time 3D content,
                                    managed spatial audio systems, server infrastructure, and projection mapping pipelines.
                                    Built and led a multicultural engineering team.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Projection Mapping</span>
                                    <span class="tech-tag">Spatial Audio</span>
                                    <span class="tech-tag">Real-time 3D</span>
                                    <span class="tech-tag">Team Leadership</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Lead Graphics Programmer</div>
                                        <div class="project-client">Little Red Dog Games</div>
                                    </div>
                                    <div class="project-year">2023</div>
                                </div>
                                <div class="project-desc">
                                    Directed graphics team to develop high-performance VFX using compute shaders and Burst-compiled code.
                                    Achieved significant CPU performance optimizations while maintaining visual fidelity.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Compute Shaders</span>
                                    <span class="tech-tag">Burst</span>
                                    <span class="tech-tag">VFX</span>
                                    <span class="tech-tag">Team Lead</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Senior Graphics Programmer</div>
                                        <div class="project-client">22cans</div>
                                    </div>
                                    <div class="project-year">2023</div>
                                </div>
                                <div class="project-desc">
                                    Created versatile shader library targeting mobile and desktop simultaneously. Developed performant
                                    grass rendering and volumetric lighting effects that maintained visual quality across hardware tiers.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">HLSL</span>
                                    <span class="tech-tag">Mobile</span>
                                    <span class="tech-tag">Volumetrics</span>
                                    <span class="tech-tag">Grass</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Shader Expert</div>
                                        <div class="project-client">GN3RA</div>
                                    </div>
                                    <div class="project-year">2023</div>
                                </div>
                                <div class="project-desc">
                                    Developed customizable HDRP cloth shaders for fashion and character rendering.
                                    Optimized visual effects and lighting systems for high-fidelity real-time applications.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">HDRP</span>
                                    <span class="tech-tag">Cloth Simulation</span>
                                    <span class="tech-tag">VFX</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Graphics Programmer</div>
                                        <div class="project-client">Scapin' Â· The Sandbox</div>
                                    </div>
                                    <div class="project-year">2021â2022</div>
                                </div>
                                <div class="project-desc">
                                    Engineered custom lighting systems for web3 social applications. Built stylized cloud shaders
                                    and optimized mobile blur effects while delivering premium visual aesthetics.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Lighting</span>
                                    <span class="tech-tag">Mobile Optimization</span>
                                    <span class="tech-tag">Web3</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Shader Expert</div>
                                        <div class="project-client">DREST</div>
                                    </div>
                                    <div class="project-year">2022</div>
                                </div>
                                <div class="project-desc">
                                    Delivered specialized shader solutions for fashion tech applications.
                                    Focused on performance optimization and high-quality material rendering.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Fashion Tech</span>
                                    <span class="tech-tag">Materials</span>
                                    <span class="tech-tag">Optimization</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Unity Developer & Technical Artist</div>
                                        <div class="project-client">Lunchbox Entertainment</div>
                                    </div>
                                    <div class="project-year">2021â2022</div>
                                </div>
                                <div class="project-desc">
                                    Created terrain, clouds, water, caustics, and bubble VFX shaders for game environments.
                                    Combined technical programming with artistic direction for immersive visual experiences.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Water Shaders</span>
                                    <span class="tech-tag">VFX</span>
                                    <span class="tech-tag">Environment Art</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Graphics Engineer</div>
                                        <div class="project-client">H3 Space</div>
                                    </div>
                                    <div class="project-year">2021</div>
                                </div>
                                <div class="project-desc">
                                    Developed graphics solutions for AR/VR applications. Specialized in performance optimization
                                    and visual effects for immersive spatial computing experiences.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">AR/VR</span>
                                    <span class="tech-tag">Optimization</span>
                                    <span class="tech-tag">3D Math</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Unity Developer & Graphics Programmer</div>
                                        <div class="project-client">Ubisoft</div>
                                    </div>
                                    <div class="project-year">2020â2021</div>
                                </div>
                                <div class="project-desc">
                                    Delivered graphics programming expertise for AAA game development.
                                    Specialized in performance analysis, VFX, and cross-platform rendering optimization.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">AAA</span>
                                    <span class="tech-tag">VFX</span>
                                    <span class="tech-tag">Performance</span>
                                </div>
                            </article>
                        </div>
                        <p class="scroll-hint">Scroll to see more</p>
                    </div>
                </div>

                <!-- Clients Panel -->
                <div class="carousel-panel clients-panel" id="panel-clients">
                    <div class="client-grid">
                        <a href="https://nexusstudios.com/" target="_blank" class="client-card">
                            <span class="client-name">Nexus Studios</span>
                        </a>
                        <a href="https://www.ubisoft.com/" target="_blank" class="client-card">
                            <span class="client-name">Ubisoft</span>
                        </a>
                        <a href="https://www.22cans.com/" target="_blank" class="client-card">
                            <span class="client-name">22cans</span>
                        </a>
                        <a href="https://www.sandbox.game/" target="_blank" class="client-card">
                            <span class="client-name">The Sandbox</span>
                        </a>
                        <a href="https://www.nexile.se/" target="_blank" class="client-card">
                            <span class="client-name">Nexile AB</span>
                        </a>
                        <a href="https://www.drest.com/" target="_blank" class="client-card">
                            <span class="client-name">DREST</span>
                        </a>
                        <a href="https://www.linkedin.com/company/h3investments/posts/" target="_blank" class="client-card">
                            <span class="client-name">H3 Space</span>
                        </a>
                        <a href="https://store.steampowered.com/developer/lrdg" target="_blank" class="client-card">
                            <span class="client-name">Little Red Dog</span>
                        </a>
                        <a href="https://scapin.io/" target="_blank" class="client-card">
                            <span class="client-name">Scapin'</span>
                        </a>
                        <a href="https://sabda.es/" target="_blank" class="client-card">
                            <span class="client-name">SABDA</span>
                        </a>
                        <a href="https://www.genera.so/" target="_blank" class="client-card">
                            <span class="client-name">GN3RA</span>
                        </a>
                        <a href="https://lunchboxentertainment.com/" target="_blank" class="client-card">
                            <span class="client-name">Lunchbox Ent.</span>
                        </a>
                    </div>
                </div>

                <!-- Testimonials Panel -->
                <div class="carousel-panel testimonials-panel" id="panel-testimonials">
                    <div class="testimonial-card">
                        <p class="testimonial-quote">He has consistently delivered the shaders I requested quickly and exactly as I needed. I would recommend him to anyone looking for a reliable expert in shader development.</p>
                        <div class="testimonial-author">
                            <div class="testimonial-avatar">MÃ</div>
                            <div class="testimonial-info">
                                <span class="testimonial-name">Mert ÃÃ¶rekÃ§i</span>
                                <span class="testimonial-role">Co-Founder & Game Developer</span>
                            </div>
                        </div>
                    </div>
                    <div class="testimonial-card">
                        <p class="testimonial-quote">Charles is communicative, quick, enthusiastic - and also very thorough! Highly knowledgeable in deep graphics functions and systems, very helpful with explanations. Charles rapidly chases down issues and finds bottlenecks and core issues, then provides concrete solutions/actions in a format understandable even to us regular mortals. I hope to work with him again!</p>
                        <div class="testimonial-author">
                            <div class="testimonial-avatar">FW</div>
                            <div class="testimonial-info">
                                <span class="testimonial-name">Felix WahlstrÃ¶m</span>
                                <span class="testimonial-role">Co-founder Nexile AB, Artist and Game Developer</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <footer>
            <div class="footer-links">
                <a href="mailto:contact.charles.grassi@gmail.com">Email</a>
                <a href="https://twitter.com/charles_grassi">Twitter</a>
                <a href="https://linkedin.com/in/charles-grassi">LinkedIn</a>
            </div>
            <p class="footer-note">Available for consulting engagements Â· Remote worldwide</p>
        </footer>
    </div>

    <script>
        // Subtle Aurora Background - Charles Grassi CV
        (function () {
            const canvas = document.getElementById('gpu-canvas');
            const renderer = new THREE.WebGLRenderer({
                canvas,
                antialias: false,
                alpha: true
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.setSize(window.innerWidth, window.innerHeight);

            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            // Mouse tracking (subtle)
            const mouse = { x: 0.5, y: 0.5, targetX: 0.5, targetY: 0.5 };
            document.addEventListener('mousemove', (e) => {
                mouse.targetX = e.clientX / window.innerWidth;
                mouse.targetY = 1.0 - e.clientY / window.innerHeight;
            });

            // Fullscreen shader
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float uTime;
                uniform vec2 uMouse;
                uniform vec2 uResolution;

                varying vec2 vUv;

                // Simplex noise
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

                float snoise(vec2 v) {
                    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                                       -0.577350269189626, 0.024390243902439);
                    vec2 i  = floor(v + dot(v, C.yy));
                    vec2 x0 = v - i + dot(i, C.xx);
                    vec2 i1;
                    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                    vec4 x12 = x0.xyxy + C.xxzz;
                    x12.xy -= i1;
                    i = mod289(i);
                    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                        + i.x + vec3(0.0, i1.x, 1.0));
                    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                        dot(x12.zw,x12.zw)), 0.0);
                    m = m*m;
                    m = m*m;
                    vec3 x = 2.0 * fract(p * C.www) - 1.0;
                    vec3 h = abs(x) - 0.5;
                    vec3 ox = floor(x + 0.5);
                    vec3 a0 = x - ox;
                    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                    vec3 g;
                    g.x = a0.x * x0.x + h.x * x0.y;
                    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                    return 130.0 * dot(m, g);
                }

                void main() {
                    vec2 uv = vUv;

                    // Slow flowing noise
                    float noise1 = snoise(uv * 1.5 + uTime * 0.05);
                    float noise2 = snoise(uv * 2.5 - uTime * 0.03 + 100.0);
                    float noise3 = snoise(uv * 0.8 + uTime * 0.02 + vec2(noise1 * 0.2));

                    float combinedNoise = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2;

                    // Colors
                    vec3 gold = vec3(0.91, 0.73, 0.14);
                    vec3 teal = vec3(0.18, 0.83, 0.75);
                    vec3 dark = vec3(0.04, 0.06, 0.08);

                    // Subtle color bands
                    float band1 = smoothstep(-0.3, 0.3, combinedNoise);
                    float band2 = smoothstep(0.0, 0.6, combinedNoise);

                    vec3 color = mix(dark, gold * 0.15, band1 * 0.4);
                    color = mix(color, teal * 0.12, band2 * 0.3);

                    // Very subtle mouse glow
                    float mouseDist = length(uv - uMouse);
                    float mouseGlow = exp(-mouseDist * 3.0) * 0.08;
                    color += teal * mouseGlow;

                    // Vignette
                    float vignette = 1.0 - length(uv - 0.5) * 0.5;
                    color *= vignette;

                    // Keep it very subtle
                    float alpha = 0.6;

                    gl_FragColor = vec4(color, alpha);
                }
            `;

            const geometry = new THREE.PlaneGeometry(2, 2);
            const material = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                },
                transparent: true,
                depthWrite: false
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Sparse floating particles
            const particleVertexShader = `
                uniform float uTime;
                uniform float uPixelRatio;
                attribute float aScale;
                attribute float aSpeed;
                varying float vAlpha;

                void main() {
                    vec3 pos = position;

                    // Gentle drift
                    pos.x += sin(uTime * aSpeed * 0.5 + position.y * 2.0) * 0.02;
                    pos.y += mod(uTime * aSpeed * 0.1, 2.0) - 1.0;
                    pos.y = mod(pos.y + 1.0, 2.0) - 1.0;

                    gl_Position = vec4(pos, 1.0);
                    gl_PointSize = aScale * uPixelRatio * 3.0;

                    // Fade at edges
                    vAlpha = smoothstep(1.0, 0.7, abs(pos.y)) * 0.4;
                }
            `;

            const particleFragmentShader = `
                varying float vAlpha;

                void main() {
                    float dist = length(gl_PointCoord - 0.5);
                    float alpha = smoothstep(0.5, 0.0, dist) * vAlpha;
                    vec3 color = mix(vec3(0.91, 0.73, 0.14), vec3(0.18, 0.83, 0.75), 0.5);
                    gl_FragColor = vec4(color, alpha);
                }
            `;

            const PARTICLE_COUNT = 60;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const scales = new Float32Array(PARTICLE_COUNT);
            const speeds = new Float32Array(PARTICLE_COUNT);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 2;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
                positions[i * 3 + 2] = 0;
                scales[i] = Math.random() * 1.5 + 0.5;
                speeds[i] = Math.random() * 0.5 + 0.2;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
            particleGeometry.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));

            const particleMaterial = new THREE.ShaderMaterial({
                vertexShader: particleVertexShader,
                fragmentShader: particleFragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }
                },
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // Animation
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);

                time += 0.016;

                mouse.x += (mouse.targetX - mouse.x) * 0.02;
                mouse.y += (mouse.targetY - mouse.y) * 0.02;

                material.uniforms.uTime.value = time;
                material.uniforms.uMouse.value.set(mouse.x, mouse.y);

                particleMaterial.uniforms.uTime.value = time;

                renderer.render(scene, camera);
            }

            animate();

            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
            });

            document.addEventListener('visibilitychange', () => {
                // Continues running but at low cost anyway
            });
        })();

        // Skill Network Graph
        (function() {
            const canvas = document.getElementById('skill-graph-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;
            let time = 0;

            // Colors matching the site theme
            const colors = {
                gold: '#e8b923',
                goldDim: '#c49a1a',
                teal: '#2dd4bf',
                tealDim: '#1a9a87',
                textPrimary: '#e8eaed',
                textMuted: '#6b7280',
                border: '#1f2937',
                bgCard: '#151d26'
            };

            // Skill nodes with categories and descriptions
            // baseSize is the reference size at 400px canvas dimension
            const skills = [
                // Core skills - first 3 are light sources with unique colors
                { id: 'unity', label: 'Unity', category: 'primary', baseSize: 34, isLight: true, lightColor: '#ffaa33',
                  desc: 'Primary game engine', usage: 'Daily since 2017 - shipped 12+ titles across mobile, PC, and VR platforms' },
                { id: 'csharp', label: 'C#', category: 'primary', baseSize: 33, isLight: true, lightColor: '#9b4dca',
                  desc: 'Main programming language', usage: '7+ years - gameplay systems, editor tools, and performance-critical code' },
                { id: 'hlsl', label: 'HLSL/GLSL', category: 'primary', baseSize: 31, isLight: true, lightColor: '#33ddff',
                  desc: 'Shader programming', usage: 'Custom rendering pipelines, VFX, post-processing, and compute shaders' },
                { id: 'directx', label: 'DirectX', category: 'secondary', baseSize: 15,
                  desc: 'Graphics API', usage: 'DX11/DX12 for Windows and Xbox development' },
                { id: 'arvr', label: 'AR/VR', category: 'secondary', baseSize: 13,
                  desc: 'Immersive experiences', usage: 'Meta Quest, HoloLens, and mobile AR projects' },
                { id: 'urp', label: 'URP/HDRP', category: 'secondary', baseSize: 13,
                  desc: 'Unity render pipelines', usage: 'Custom render features, shader graphs, and pipeline extensions' },

                // Secondary skills (teal)
                { id: 'opengl', label: 'OpenGL', category: 'secondary', baseSize: 14,
                  desc: 'Cross-platform graphics', usage: 'Mobile and Linux rendering targets' },
                { id: 'unreal', label: 'Unreal', category: 'secondary', baseSize: 16,
                  desc: 'Secondary engine', usage: 'Blueprint systems and material editor for specific projects' },
                { id: 'vulkan', label: 'Vulkan', category: 'secondary', baseSize: 15,
                  desc: 'Low-level graphics API', usage: 'Performance optimization on Android and Linux' },
                { id: 'python', label: 'Python', category: 'secondary', baseSize: 14,
                  desc: 'Scripting & tools', usage: 'Build automation, asset pipelines, and data processing' },
                { id: 'cpp', label: 'C++', category: 'secondary', baseSize: 8,
                  desc: 'Systems programming', usage: 'Native plugins, engine modifications, and Unreal development' },
                { id: 'wpf', label: 'WPF', category: 'secondary', baseSize: 12,
                  desc: 'Desktop UI framework', usage: 'Internal tools and editors for game development' },
                { id: 'compute', label: 'Compute', category: 'secondary', baseSize: 17,
                  desc: 'GPU compute shaders', usage: 'Particle simulations, procedural generation, and physics' },
                { id: 'vfx', label: 'VFX Graph', category: 'secondary', baseSize: 12,
                  desc: 'Unity visual effects', usage: 'GPU-driven particle systems and real-time simulations' },
                { id: 'niagara', label: 'Niagara', category: 'secondary', baseSize: 17,
                  desc: 'Unreal VFX system', usage: 'Complex particle effects for Unreal projects' },
                { id: 'threejs', label: 'Three.js', category: 'secondary', baseSize: 8,
                  desc: 'WebGL framework', usage: 'Interactive 3D web experiences and visualizations' },
                { id: 'webgl', label: 'WebGL', category: 'secondary', baseSize: 6,
                  desc: 'Browser graphics', usage: 'Custom shaders and real-time web graphics' },

                // Tools (muted)
                { id: 'renderdoc', label: 'RenderDoc', category: 'tool', baseSize: 16,
                  desc: 'Graphics debugger', usage: 'Frame analysis and shader debugging' },
                { id: 'nsight', label: 'NSight', category: 'tool', baseSize: 14,
                  desc: 'NVIDIA profiler', usage: 'GPU performance analysis and optimization' },
                { id: 'pix', label: 'PIX', category: 'tool', baseSize: 6,
                  desc: 'DirectX debugger', usage: 'Windows and Xbox graphics debugging' }
            ];

            // Reference dimension for scaling (sizes are designed for this)
            const BASE_DIMENSION = 400;
            let sizeScale = 1;

            // Connections between skills
            const connections = [
                ['unity', 'csharp'], ['unity', 'hlsl'], ['unity', 'urp'], ['unity', 'arvr'],
                ['unity', 'vfx'], ['unity', 'compute'],
                ['csharp', 'wpf'], ['csharp', 'compute'],
                ['hlsl', 'directx'], ['hlsl', 'opengl'], ['hlsl', 'vulkan'], ['hlsl', 'urp'],
                ['directx', 'renderdoc'], ['directx', 'pix'], ['directx', 'nsight'],
                ['opengl', 'vulkan'], ['opengl', 'webgl'],
                ['unreal', 'cpp'], ['unreal', 'niagara'], ['unreal', 'hlsl'],
                ['cpp', 'directx'], ['cpp', 'vulkan'],
                ['compute', 'vfx'], ['compute', 'hlsl'],
                ['threejs', 'webgl'], ['threejs', 'hlsl'],
                ['arvr', 'urp'], ['arvr', 'compute'],
                ['vfx', 'niagara'],
                ['python', 'unity']
            ];

            // Initialize node positions with unique animation properties
            let nodes = skills.map((skill, i) => {
                const angle = (i / skills.length) * Math.PI * 2;
                const radius = 150 + Math.random() * 50;
                return {
                    ...skill,
                    size: skill.baseSize, // Will be updated on resize
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    baseX: 0,
                    baseY: 0,
                    // Animation parameters for slow organic movement
                    floatSpeed: 0.03 + Math.random() * 0.03,
                    floatRadius: 2 + Math.random() * 3,
                    floatPhase: Math.random() * Math.PI * 2,
                    floatSpeed2: 0.02 + Math.random() * 0.02, // Secondary wobble
                    floatRadius2: 1 + Math.random() * 2,
                    pulseSpeed: 0.05 + Math.random() * 0.1,
                    pulsePhase: Math.random() * Math.PI * 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.001,
                    // Orbit behavior for non-light nodes
                    orbitAngle: Math.random() * Math.PI * 2,
                    orbitSpeed: 0.02 + Math.random() * 0.02,
                    orbitRadius: 2 + Math.random() * 4,
                    // Glow animation state
                    glowIntensity: 0,
                    targetGlowIntensity: 0,
                    glowDelay: 0,
                    // Shrink animation for non-connected nodes
                    shrinkProgress: 1, // 1 = full size, 0 = invisible
                    targetShrink: 1
                };
            });

            let width, height, centerX, centerY;
            let isDragging = false;
            let dragNode = null;
            let hoveredNode = null;
            let mouseX = 0, mouseY = 0;
            let settled = false;
            let settleTimer = 0;
            let startupPhase = true; // Delays showcase until nodes appear
            let globalFadeIn = 0; // Simple 0-1 fade in for all nodes

            // Tooltip element and connector line
            const tooltip = document.getElementById('skill-tooltip');
            const tooltipTitle = tooltip.querySelector('.skill-tooltip-title');
            const tooltipDesc = tooltip.querySelector('.skill-tooltip-desc');
            const tooltipUsage = tooltip.querySelector('.skill-tooltip-usage');

            let tooltipTarget = null; // Current node the tooltip is attached to
            let tooltipPos = { x: 0, y: 0 }; // Position for tooltip
            let tooltipConnectPoint = { x: 0, y: 0 }; // Connection point on tooltip edge
            let lineAnimProgress = 0; // Animation progress 0-1
            let lineAnimStartTime = 0;
            const lineAnimDuration = 300; // ms for line to draw
            let tooltipSide = 'right'; // 'left' or 'right'

            // Random skill showcase (shows tooltip without hover effects)
            let showcaseNode = null;
            let showcaseActive = false;
            let lastShowcaseTime = 0;
            const showcaseInterval = 2000; // Time between showcases
            const showcaseDuration = 4000; // How long to show each showcase

            function startRandomShowcase() {
                // Don't start if user is hovering, dragging, or during startup
                if (hoveredNode || isDragging || startupPhase) return;

                // Pick a random node that isn't the current showcase
                const availableNodes = nodes.filter(n => n !== showcaseNode);
                if (availableNodes.length === 0) return;

                showcaseNode = availableNodes[Math.floor(Math.random() * availableNodes.length)];
                showcaseActive = true;

                // Generate tooltip position and show it
                generateTooltipPosition(showcaseNode);
                tooltipTarget = showcaseNode;
                tooltipTitle.textContent = showcaseNode.label;
                tooltipDesc.textContent = showcaseNode.desc || '';
                tooltipUsage.textContent = showcaseNode.usage || '';
                tooltip.className = 'skill-tooltip ' + showcaseNode.category;
                tooltip.style.left = tooltipPos.x + 'px';
                tooltip.style.top = tooltipPos.y + 'px';

                lastShowcaseTime = performance.now();
            }

            function updateShowcase() {
                const now = performance.now();

                // Don't run showcase during startup phase
                if (startupPhase) {
                    lastShowcaseTime = now; // Keep resetting timer
                    return;
                }

                // If user hovers, cancel the showcase
                if (hoveredNode || isDragging) {
                    if (showcaseActive && tooltipTarget === showcaseNode) {
                        // User took over - let the hover handle it
                        showcaseActive = false;
                        showcaseNode = null;
                    }
                    lastShowcaseTime = now; // Reset timer
                    return;
                }

                // If showcase is active, check if it should end
                if (showcaseActive) {
                    if (now - lastShowcaseTime > showcaseDuration) {
                        // End showcase
                        showcaseActive = false;
                        tooltip.classList.remove('visible');
                        tooltipTarget = null;
                        lineAnimProgress = 0;
                        lastShowcaseTime = now;
                    }
                    return;
                }

                // Check if it's time for a new showcase
                if (now - lastShowcaseTime > showcaseInterval) {
                    startRandomShowcase();
                }
            }

            // Offset from node to tooltip (set once when tooltip appears)
            let tooltipOffset = { x: 0, y: 0 };
            const tooltipWidth = 260;
            const tooltipHeight = 120;

            function generateTooltipPosition(node) {
                const margin = 20;

                // Randomly choose left or right side
                tooltipSide = Math.random() > 0.5 ? 'right' : 'left';

                let tx, ty;

                if (tooltipSide === 'right') {
                    // Position on right side of canvas
                    tx = width - tooltipWidth - margin;
                } else {
                    // Position on left side of canvas
                    tx = margin;
                }

                // Random vertical position, but try to align somewhat with node
                const minY = margin;
                const maxY = height - tooltipHeight - margin;
                ty = node.y - tooltipHeight / 2 + (Math.random() - 0.5) * 100;
                ty = Math.max(minY, Math.min(maxY, ty));

                tooltipPos = { x: tx, y: ty };

                // Store offset from node position to tooltip position
                tooltipOffset = { x: tx - node.x, y: ty - node.y };

                // Connection point is on the edge facing the node
                if (tooltipSide === 'right') {
                    tooltipConnectPoint = {
                        x: tx,
                        y: ty + tooltipHeight / 2
                    };
                } else {
                    tooltipConnectPoint = {
                        x: tx + tooltipWidth,
                        y: ty + tooltipHeight / 2
                    };
                }

                // Start line animation
                lineAnimProgress = 0;
                lineAnimStartTime = performance.now();
            }

            function updateTooltipPositionForDrag(node) {
                // Update tooltip position maintaining the offset from the node
                const margin = 20;
                let tx = node.x + tooltipOffset.x;
                let ty = node.y + tooltipOffset.y;

                // Clamp to canvas bounds
                tx = Math.max(margin, Math.min(width - tooltipWidth - margin, tx));
                ty = Math.max(margin, Math.min(height - tooltipHeight - margin, ty));

                tooltipPos = { x: tx, y: ty };

                // Update connection point
                if (tooltipSide === 'right') {
                    tooltipConnectPoint = {
                        x: tx,
                        y: ty + tooltipHeight / 2
                    };
                } else {
                    tooltipConnectPoint = {
                        x: tx + tooltipWidth,
                        y: ty + tooltipHeight / 2
                    };
                }

                tooltip.style.left = tooltipPos.x + 'px';
                tooltip.style.top = tooltipPos.y + 'px';
            }

            function updateTooltip(node, forceKeep = false) {
                if (node) {
                    // Only generate new position if hovering a new node (and not dragging)
                    if (tooltipTarget !== node && !isDragging) {
                        tooltipTarget = node;
                        generateTooltipPosition(node);
                        // Hide tooltip initially - will show when line finishes
                        tooltip.classList.remove('visible');
                    }

                    tooltipTitle.textContent = node.label;
                    tooltipDesc.textContent = node.desc || '';
                    tooltipUsage.textContent = node.usage || '';

                    // Set category class for color (visible class added when line completes)
                    tooltip.className = 'skill-tooltip ' + node.category + (lineAnimProgress >= 1 ? ' visible' : '');

                    tooltip.style.left = tooltipPos.x + 'px';
                    tooltip.style.top = tooltipPos.y + 'px';
                } else if (!forceKeep) {
                    tooltip.classList.remove('visible');
                    tooltipTarget = null;
                    lineAnimProgress = 0;
                }
            }

            function drawTooltipConnector() {
                if (!tooltipTarget) return;

                // Update animation progress
                const elapsed = performance.now() - lineAnimStartTime;
                lineAnimProgress = Math.min(1, elapsed / lineAnimDuration);

                // Show tooltip when line completes
                if (lineAnimProgress >= 1 && !tooltip.classList.contains('visible')) {
                    tooltip.classList.add('visible');
                }

                const node = tooltipTarget;
                const nodeX = node.x;
                const nodeY = node.y;
                const connX = tooltipConnectPoint.x;
                const connY = tooltipConnectPoint.y;

                // Get line color based on category
                let lineColor;
                if (node.category === 'primary') {
                    lineColor = colors.gold;
                } else if (node.category === 'secondary') {
                    lineColor = colors.teal;
                } else {
                    lineColor = colors.textMuted;
                }

                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.8;

                // Calculate the corner point for L-shape
                // First go vertical from node, then horizontal to tooltip
                const cornerX = nodeX;
                const cornerY = connY;

                // Calculate total line length for animation
                const verticalDist = Math.abs(cornerY - nodeY);
                const horizontalDist = Math.abs(connX - cornerX);
                const totalDist = verticalDist + horizontalDist;

                // How much of the line to draw based on animation progress
                const drawDist = totalDist * lineAnimProgress;

                ctx.beginPath();
                ctx.moveTo(nodeX, nodeY);

                if (drawDist <= verticalDist) {
                    // Still drawing vertical portion
                    const progress = drawDist / verticalDist;
                    const currentY = nodeY + (cornerY - nodeY) * progress;
                    ctx.lineTo(nodeX, currentY);
                } else {
                    // Vertical complete, drawing horizontal
                    ctx.lineTo(cornerX, cornerY);
                    const remainingDist = drawDist - verticalDist;
                    const horizontalProgress = remainingDist / horizontalDist;
                    const currentX = cornerX + (connX - cornerX) * horizontalProgress;
                    ctx.lineTo(currentX, cornerY);
                }

                ctx.stroke();
                ctx.globalAlpha = 1;

                // Draw small circle at node connection point
                ctx.beginPath();
                ctx.arc(nodeX, nodeY, 3, 0, Math.PI * 2);
                ctx.fillStyle = lineColor;
                ctx.fill();
            }

            function resize() {
                const rect = container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                width = rect.width;
                height = rect.height;
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                centerX = width / 2;
                centerY = height / 2;
                settled = false;
                settleTimer = 0;

                // Calculate size scale based on canvas dimensions
                // Use the smaller dimension for scaling, with min/max limits
                const minDim = Math.min(width, height);
                sizeScale = Math.max(0.5, Math.min(1.2, minDim / BASE_DIMENSION));

                // Initialize positions spread out
                nodes.forEach((node, i) => {
                    const angle = (i / nodes.length) * Math.PI * 2 + Math.PI / 4;
                    const radius = Math.min(width, height) * 0.35;
                    node.x = centerX + Math.cos(angle) * radius * (0.6 + Math.random() * 0.4);
                    node.y = centerY + Math.sin(angle) * radius * (0.6 + Math.random() * 0.4);
                    node.baseX = node.x;
                    node.baseY = node.y;
                    node.vx = 0;
                    node.vy = 0;
                    // Update node size based on scale
                    node.size = node.baseSize * sizeScale;
                });

                // Resize WebGL canvas
                resizeSphereGL();
            }

            function getNodeAt(x, y) {
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const node = nodes[i];
                    const dx = x - node.x;
                    const dy = y - node.y;
                    const hitRadius = node.size + 5;
                    if (dx * dx + dy * dy < hitRadius * hitRadius) {
                        return node;
                    }
                }
                return null;
            }

            function getConnectedNodes(node) {
                const connected = new Set();
                connections.forEach(([a, b]) => {
                    if (a === node.id) connected.add(b);
                    if (b === node.id) connected.add(a);
                });
                return connected;
            }

            // Physics simulation - stronger forces when dragging
            function simulate() {
                // Simple global fade in - delay 1.5s then fade over 2s
                if (globalFadeIn < 1) {
                    if (time > 1.5) {
                        globalFadeIn = Math.min(1, (time - 1.5) / 2);
                    }
                }

                // End startup phase when fully visible
                if (globalFadeIn >= 1) {
                    startupPhase = false;
                }

                // Scale physics parameters based on canvas size
                const scaleSquared = sizeScale * sizeScale;

                // Normal physics - runs even during startup (nodes are just invisible)
                const repulsion = (dragNode ? 5000 : 3000) * scaleSquared;
                const attraction = dragNode ? 0.0015 : 0.003;
                const damping = 0.95;
                const centerPull = 0.002;

                let totalMovement = 0;

                nodes.forEach((nodeA, idxA) => {
                    if (nodeA === dragNode) return;

                    let fx = 0, fy = 0;

                    // Strong repulsion from ALL other nodes (not just nearby)
                    nodes.forEach((nodeB, idxB) => {
                        if (nodeA === nodeB) return;
                        const dx = nodeA.x - nodeB.x;
                        const dy = nodeA.y - nodeB.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const minDist = (nodeA.size + nodeB.size + 80 * sizeScale);

                        // Always apply some repulsion, stronger when close
                        const force = repulsion / (dist * dist + 100);
                        fx += (dx / dist) * force;
                        fy += (dy / dist) * force;
                    });

                    // Gentle attraction along connections (longer ideal distance)
                    // When dragging, connected nodes are pulled much more strongly
                    connections.forEach(([a, b]) => {
                        let other = null;
                        if (a === nodeA.id) other = nodes.find(n => n.id === b);
                        if (b === nodeA.id) other = nodes.find(n => n.id === a);
                        if (other) {
                            const dx = other.x - nodeA.x;
                            const dy = other.y - nodeA.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const idealDist = 180 * sizeScale; // Longer connections

                            // Much stronger pull if connected to the dragged node
                            const isDragConnected = dragNode && (other === dragNode || nodeA === dragNode);
                            const dragMultiplier = isDragConnected ? 15 : 1;

                            if (dist > idealDist || isDragConnected) {
                                const baseStrength = (dist - idealDist) * attraction;
                                const strength = Math.max(baseStrength, isDragConnected ? 0.05 : 0) * dragMultiplier;
                                fx += (dx / dist) * strength;
                                fy += (dy / dist) * strength;
                            }
                        }
                    });

                    // Light sources orbit very slowly around center
                    if (nodeA.isLight) {
                        const orbitRadius = 80 * sizeScale;
                        const orbitSpeed = 0.06 + idxA * 0.01;
                        const orbitPhase = idxA * (Math.PI * 2 / 3);
                        const targetX = centerX + Math.cos(time * orbitSpeed + orbitPhase) * orbitRadius;
                        const targetY = centerY + Math.sin(time * orbitSpeed + orbitPhase) * orbitRadius;
                        fx += (targetX - nodeA.x) * 0.02;
                        fy += (targetY - nodeA.y) * 0.02;
                    }

                    // Pull toward center (weaker for more spread)
                    fx += (centerX - nodeA.x) * centerPull;
                    fy += (centerY - nodeA.y) * centerPull;

                    // Subtle mouse attraction/interaction
                    const mouseDx = mouseX - nodeA.x;
                    const mouseDy = mouseY - nodeA.y;
                    const mouseDist = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);
                    if (mouseDist < 200 * sizeScale && mouseDist > 30) {
                        // Gentle push away from mouse
                        const mouseForce = 0.5 / (mouseDist * 0.1 + 1);
                        fx -= (mouseDx / mouseDist) * mouseForce;
                        fy -= (mouseDy / mouseDist) * mouseForce;
                    }

                    // Apply forces with damping
                    nodeA.vx = (nodeA.vx + fx * 0.08) * damping;
                    nodeA.vy = (nodeA.vy + fy * 0.08) * damping;
                    nodeA.x += nodeA.vx;
                    nodeA.y += nodeA.vy;

                    totalMovement += Math.abs(nodeA.vx) + Math.abs(nodeA.vy);

                    // Keep within bounds with soft bounce
                    const padding = 60;
                    if (nodeA.x < padding) { nodeA.x = padding; nodeA.vx *= -0.5; }
                    if (nodeA.x > width - padding) { nodeA.x = width - padding; nodeA.vx *= -0.5; }
                    if (nodeA.y < padding) { nodeA.y = padding; nodeA.vy *= -0.5; }
                    if (nodeA.y > height - padding) { nodeA.y = height - padding; nodeA.vy *= -0.5; }

                    // Update base position for floating animation
                    nodeA.baseX = nodeA.x;
                    nodeA.baseY = nodeA.y;
                });

                // Never fully settle - keep subtle movement
                if (totalMovement < 0.5) {
                    settleTimer++;
                    if (settleTimer > 60) {
                        settled = true;
                    }
                } else {
                    settleTimer = 0;
                    settled = false;
                }
            }

            // ================================================
            // WEBGL SDF SPHERE RENDERER - PBR LIGHTING
            // ================================================
            let gl, glCanvas, sphereProgram, glReady = false;

            function initSphereGL() {
                glCanvas = document.createElement('canvas');
                glCanvas.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1;';
                container.insertBefore(glCanvas, container.firstChild);

                gl = glCanvas.getContext('webgl', { alpha: true, antialias: true, premultipliedAlpha: false });
                if (!gl) return false;

                const vert = `
                    attribute vec2 aPos;
                    attribute vec2 aCenter;
                    attribute float aRadius;
                    attribute vec3 aColor;
                    attribute float aAlpha;
                    attribute float aAppear;
                    attribute float aGlow;
                    attribute float aIndex;
                    attribute float aIsLight;
                    varying vec2 vUV;
                    varying vec2 vCenter;
                    varying float vRadius;
                    varying vec3 vColor;
                    varying float vAlpha;
                    varying float vAppear;
                    varying float vGlow;
                    varying float vIndex;
                    varying float vIsLight;
                    uniform vec2 uRes;
                    void main() {
                        vUV = aPos;
                        vCenter = aCenter;
                        vRadius = aRadius;
                        vColor = aColor;
                        vAlpha = aAlpha;
                        vAppear = aAppear;
                        vGlow = aGlow;
                        vIndex = aIndex;
                        vIsLight = aIsLight;
                        vec2 p = aCenter + aPos * aRadius * 3.0;
                        vec2 c = (p / uRes) * 2.0 - 1.0;
                        gl_Position = vec4(c.x, -c.y, 0.0, 1.0);
                    }
                `;

                const frag = `
                    precision highp float;
                    varying vec2 vUV;
                    varying vec2 vCenter;
                    varying float vRadius;
                    varying vec3 vColor;
                    varying float vAlpha;
                    varying float vAppear;
                    varying float vGlow;
                    varying float vIndex;
                    varying float vIsLight;
                    uniform vec2 uRes;
                    uniform vec2 uMouse;
                    uniform float uTime;
                    uniform vec2 uLight0;
                    uniform vec2 uLight1;
                    uniform vec2 uLight2;
                    uniform vec3 uLightColor0;
                    uniform vec3 uLightColor1;
                    uniform vec3 uLightColor2;

                    #define PI 3.14159265

                    void main() {
                        vec2 uv = vUV;
                        float d = length(uv);

                        // Index-based animation offset
                        float animOffset = vIndex * 0.5;
                        float t = uTime + animOffset;

                        // Appear animation
                        float ap = clamp(vAppear, 0.0, 1.0);
                        float scaledD = d / max(ap, 0.001);

                        // Soft outer fade to avoid hard edge artifacts
                        float outerFade = 1.0 - smoothstep(1.2, 1.45, scaledD);
                        if (outerFade < 0.001) discard;

                        // --- PLANET PARAMETERS ---
                        float planetRadius = 0.40;
                        float atmosphereThickness = 0.65;
                        float atmosphereOuter = planetRadius + atmosphereThickness;

                        // --- CHECK IF THIS IS A LIGHT SOURCE ---
                        if (vIsLight > 0.5) {
                            // Render as glowing emissive orb
                            float coreMask = 1.0 - smoothstep(0.0, 0.5, d);
                            float glowMask = 1.0 - smoothstep(0.0, 1.0, d);
                            float outerHalo = 0.03 / (d * d + 0.03);

                            // Pulsing animation
                            float pulse = sin(t * 2.0) * 0.5 + 0.5;
                            float breathe = 0.85 + pulse * 0.15;

                            // Emissive color (brighter than base)
                            vec3 emissive = vColor * 1.5;
                            vec3 col = vec3(0.0);

                            // Bright core
                            col += emissive * coreMask * 2.0 * breathe;

                            // Inner glow
                            col += emissive * glowMask * 0.8;

                            // Outer halo
                            col += emissive * outerHalo * 0.6;

                            // Hover boost
                            col += vColor * vGlow * 0.5;

                            // Tone mapping
                            col = col / (col + vec3(0.5));

                            float alpha = coreMask * 0.95 + glowMask * 0.5 + outerHalo * 0.4;
                            alpha = clamp(alpha, 0.0, 1.0) * outerFade;
                            alpha *= smoothstep(0.0, 0.5, ap) * vAlpha;

                            gl_FragColor = vec4(col, alpha);
                            return;
                        }

                        // --- PLANET COLOR VARIATION based on index ---
                        float varSeed = vIndex * 1.618;
                        vec3 planetColor = vColor;
                        // Hue shift
                        float hueShift = sin(varSeed) * 0.1;
                        planetColor.r += hueShift;
                        planetColor.g += hueShift;
                        planetColor.b -= hueShift;
                        // Saturation variation
                        float satVar = cos(varSeed * 2.3) * 0.5;
                        vec3 gray = vec3(dot(planetColor, vec3(0.299, 0.587, 0.114)));
                        planetColor = mix(planetColor, gray, .8);
                        // Brightness variation
                        planetColor *= 0.9 + sin(varSeed * 3.7) * 0.15;

                        // --- PLANET SURFACE ---
                        float planetMask = 1.0 - smoothstep(planetRadius - 0.0002, planetRadius, d);

                        // Sphere normal
                        float zSq = planetRadius * planetRadius - d * d;
                        float z = zSq > 0.0 ? sqrt(zSq) : 0.0;
                        vec3 N = d < planetRadius ? normalize(vec3(uv, z)) : vec3(0.0, 0.0, 1.0);
                        vec3 V = vec3(0.0, 0.0, 1.0);

                        // --- ACCUMULATE LIGHTING FROM ALL SOURCES ---
                        vec3 totalDiffuse = vec3(0.0);
                        vec3 totalSpecular = vec3(0.0);
                        float totalAttenuation = 0.0;

                        // Mouse light (white)
                        vec2 mouseOffset = (uMouse - vCenter);
                        vec3 mouseLightPos = vec3(mouseOffset / uRes.x * 4.0, 0.3);
                        vec3 mouseL = normalize(mouseLightPos);
                        float mouseDist = length(mouseLightPos);
                        float mouseAtten = 0.08 / (mouseDist * mouseDist + 0.01);
                        mouseAtten = min(mouseAtten, 2.0);

                        float mouseNdL = max(dot(N, mouseL), 0.0);
                        vec3 mouseH = normalize(mouseL + V);
                        float mouseNdH = max(dot(N, mouseH), 0.0);
                        totalDiffuse += vec3(1.0) * mouseNdL * mouseAtten;
                        totalSpecular += vec3(1.0) * pow(mouseNdH, 32.0) * mouseAtten;
                        totalAttenuation += mouseAtten;

                        // Point light 0 (Unity - orange)
                        vec2 light0Offset = (uLight0 - vCenter);
                        vec3 light0Pos = vec3(light0Offset / uRes.x * 3.0, 0.1);
                        vec3 L0 = normalize(light0Pos);
                        float dist0 = length(light0Pos);
                        float atten0 = 0.06 / (dist0 * dist0 + 0.02);
                        atten0 = min(atten0, 1.5);

                        float NdL0 = max(dot(N, L0), 0.0);
                        vec3 H0 = normalize(L0 + V);
                        float NdH0 = max(dot(N, H0), 0.0);
                        totalDiffuse += uLightColor0 * NdL0 * atten0;
                        totalSpecular += uLightColor0 * pow(NdH0, 32.0) * atten0;
                        totalAttenuation += atten0;

                        // Point light 1 (C# - purple)
                        vec2 light1Offset = (uLight1 - vCenter);
                        vec3 light1Pos = vec3(light1Offset / uRes.x * 3.0, 0.1);
                        vec3 L1 = normalize(light1Pos);
                        float dist1 = length(light1Pos);
                        float atten1 = 0.06 / (dist1 * dist1 + 0.02);
                        atten1 = min(atten1, 1.5);

                        float NdL1 = max(dot(N, L1), 0.0);
                        vec3 H1 = normalize(L1 + V);
                        float NdH1 = max(dot(N, H1), 0.0);
                        totalDiffuse += uLightColor1 * NdL1 * atten1;
                        totalSpecular += uLightColor1 * pow(NdH1, 32.0) * atten1;
                        totalAttenuation += atten1;

                        // Point light 2 (HLSL - cyan)
                        vec2 light2Offset = (uLight2 - vCenter);
                        vec3 light2Pos = vec3(light2Offset / uRes.x * 3.0, 0.1);
                        vec3 L2 = normalize(light2Pos);
                        float dist2 = length(light2Pos);
                        float atten2 = 0.06 / (dist2 * dist2 + 0.02);
                        atten2 = min(atten2, 1.5);

                        float NdL2 = max(dot(N, L2), 0.0);
                        vec3 H2 = normalize(L2 + V);
                        float NdH2 = max(dot(N, H2), 0.0);
                        totalDiffuse += uLightColor2 * NdL2 * atten2;
                        totalSpecular += uLightColor2 * pow(NdH2, 32.0) * atten2;
                        totalAttenuation += atten2;

                        // --- ATMOSPHERE ---
                        float atmosDist = d - planetRadius;
                        float atmosMask = smoothstep(atmosphereOuter, planetRadius, d);
                        float atmosDensity = atmosMask * (1.0 - planetMask);
                        vec3 atmosColor = planetColor * 1.2 + vec3(0.05, 0.08, 0.15);

                        float NdV = max(dot(N, V), 0.0);
                        float limbAngle = 1.0 - abs(dot(N, V));
                        float limbGlow = pow(limbAngle, 2.0) * atmosMask;

                        float ringDist = abs(d - planetRadius);
                        float atmosRing = exp(-ringDist * 8.0) * 0.6;

                        float outerGlow = 0.0;
                        if (d > planetRadius) {
                            float glowDist = d - planetRadius;
                            outerGlow = exp(-glowDist * 4.0) * 0.5;
                            outerGlow += 0.015 / (glowDist + 0.02);
                        }

                        // --- COMPOSE FINAL COLOR ---
                        vec3 col = vec3(0.0);
                        vec3 surfaceColor = planetColor * 0.85;

                        // Lit surface
                        col += surfaceColor * totalDiffuse * 1.5 * planetMask;
                        col += planetColor * totalSpecular * 0.3 * planetMask;

                        // Ambient for dark side
                        col += surfaceColor * 0.02 * planetMask;

                        // Atmosphere effects
                        col += atmosColor * limbGlow * totalAttenuation * 0.3 * planetMask;
                        col += planetColor * atmosRing * totalAttenuation * 0.2;
                        col += planetColor * outerGlow * totalAttenuation * 0.4;

                        // Fresnel
                        float fresnel = pow(1.0 - NdV, 4.0) * planetMask;
                        col += planetColor * fresnel * totalAttenuation * 0.2;

                        // Hover
                        col += planetColor * vGlow * (0.15 + fresnel * 0.3);

                        // Tone mapping
                        col = col / (col + vec3(0.7));
                        col = pow(col, vec3(0.95));

                        // Alpha
                        float alpha = 0.0;
                        alpha += planetMask * 0.98;
                        alpha += atmosDensity * 0.4;
                        alpha += atmosRing * 0.2;
                        alpha += outerGlow * 0.3;
                        alpha = clamp(alpha, 0.0, 1.0);
                        alpha *= outerFade;
                        alpha *= smoothstep(0.0, 0.5, ap);
                        alpha *= vAlpha;

                        gl_FragColor = vec4(col, alpha);
                    }
                `;

                function comp(s, t) {
                    const sh = gl.createShader(t);
                    gl.shaderSource(sh, s);
                    gl.compileShader(sh);
                    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
                        console.error(gl.getShaderInfoLog(sh));
                        return null;
                    }
                    return sh;
                }

                const vs = comp(vert, gl.VERTEX_SHADER);
                const fs = comp(frag, gl.FRAGMENT_SHADER);
                if (!vs || !fs) return false;

                sphereProgram = gl.createProgram();
                gl.attachShader(sphereProgram, vs);
                gl.attachShader(sphereProgram, fs);
                gl.linkProgram(sphereProgram);

                if (!gl.getProgramParameter(sphereProgram, gl.LINK_STATUS)) {
                    console.error(gl.getProgramInfoLog(sphereProgram));
                    return false;
                }

                sphereProgram.aPos = gl.getAttribLocation(sphereProgram, 'aPos');
                sphereProgram.aCenter = gl.getAttribLocation(sphereProgram, 'aCenter');
                sphereProgram.aRadius = gl.getAttribLocation(sphereProgram, 'aRadius');
                sphereProgram.aColor = gl.getAttribLocation(sphereProgram, 'aColor');
                sphereProgram.aAlpha = gl.getAttribLocation(sphereProgram, 'aAlpha');
                sphereProgram.aAppear = gl.getAttribLocation(sphereProgram, 'aAppear');
                sphereProgram.aGlow = gl.getAttribLocation(sphereProgram, 'aGlow');
                sphereProgram.aIndex = gl.getAttribLocation(sphereProgram, 'aIndex');
                sphereProgram.aIsLight = gl.getAttribLocation(sphereProgram, 'aIsLight');
                sphereProgram.uRes = gl.getUniformLocation(sphereProgram, 'uRes');
                sphereProgram.uMouse = gl.getUniformLocation(sphereProgram, 'uMouse');
                sphereProgram.uTime = gl.getUniformLocation(sphereProgram, 'uTime');
                sphereProgram.uLight0 = gl.getUniformLocation(sphereProgram, 'uLight0');
                sphereProgram.uLight1 = gl.getUniformLocation(sphereProgram, 'uLight1');
                sphereProgram.uLight2 = gl.getUniformLocation(sphereProgram, 'uLight2');
                sphereProgram.uLightColor0 = gl.getUniformLocation(sphereProgram, 'uLightColor0');
                sphereProgram.uLightColor1 = gl.getUniformLocation(sphereProgram, 'uLightColor1');
                sphereProgram.uLightColor2 = gl.getUniformLocation(sphereProgram, 'uLightColor2');
                sphereProgram.buf = gl.createBuffer();

                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.clearColor(0, 0, 0, 0);

                glReady = true;
                return true;
            }

            function resizeSphereGL() {
                if (!glReady) return;
                glCanvas.width = width * (window.devicePixelRatio || 1);
                glCanvas.height = height * (window.devicePixelRatio || 1);
                gl.viewport(0, 0, glCanvas.width, glCanvas.height);
            }

            function hex2vec(h) {
                return [parseInt(h.slice(1,3),16)/255, parseInt(h.slice(3,5),16)/255, parseInt(h.slice(5,7),16)/255];
            }

            function renderSpheresGL(nodes, hovered, connected) {
                if (!glReady) return false;

                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(sphereProgram);
                gl.uniform2f(sphereProgram.uRes, width, height);
                gl.uniform2f(sphereProgram.uMouse, mouseX, mouseY);
                gl.uniform1f(sphereProgram.uTime, time);

                // Find light source positions and colors (Unity, C#, HLSL)
                const lightNodes = nodes.filter(n => n.isLight);
                const light0 = lightNodes[0] || { x: 0, y: 0, lightColor: '#ffaa33' };
                const light1 = lightNodes[1] || { x: 0, y: 0, lightColor: '#9b4dca' };
                const light2 = lightNodes[2] || { x: 0, y: 0, lightColor: '#33ddff' };
                gl.uniform2f(sphereProgram.uLight0, light0.x, light0.y);
                gl.uniform2f(sphereProgram.uLight1, light1.x, light1.y);
                gl.uniform2f(sphereProgram.uLight2, light2.x, light2.y);
                // Individual light colors
                const lc0 = hex2vec(light0.lightColor || '#ffaa33');
                const lc1 = hex2vec(light1.lightColor || '#9b4dca');
                const lc2 = hex2vec(light2.lightColor || '#33ddff');
                gl.uniform3f(sphereProgram.uLightColor0, lc0[0], lc0[1], lc0[2]);
                gl.uniform3f(sphereProgram.uLightColor1, lc1[0], lc1[1], lc1[2]);
                gl.uniform3f(sphereProgram.uLightColor2, lc2[0], lc2[1], lc2[2]);

                const v = [];
                const q = [[-1,-1],[1,-1],[1,1],[-1,-1],[1,1],[-1,1]];

                nodes.forEach((n, idx) => {
                    // Skip fully shrunk nodes
                    const shrink = n.shrinkProgress !== undefined ? n.shrinkProgress : 1;
                    if (shrink < 0.01) return;

                    let c;
                    // Light sources use their own lightColor, others use category color
                    if (n.isLight && n.lightColor) {
                        c = hex2vec(n.lightColor);
                    } else if (n.category === 'primary') {
                        c = hex2vec(colors.gold);
                    } else if (n.category === 'secondary') {
                        c = hex2vec(colors.teal);
                    } else {
                        c = hex2vec(colors.textMuted);
                    }

                    const g = n.glowIntensity || 0;
                    const p = Math.sin(time * n.pulseSpeed + n.pulsePhase);
                    // Apply shrink to radius
                    const baseR = n.size + p * 0.5 + g * 3;
                    const r = baseR * shrink;
                    const ap = globalFadeIn * shrink; // Use global fade in
                    const a = shrink * globalFadeIn; // Alpha also follows fade in
                    const nodeIndex = idx;
                    const isLight = n.isLight ? 1.0 : 0.0;

                    q.forEach(([qx,qy]) => {
                        v.push(qx, qy, n.x, n.y, r, c[0], c[1], c[2], a, ap, g, nodeIndex, isLight);
                    });
                });

                const d = new Float32Array(v);
                gl.bindBuffer(gl.ARRAY_BUFFER, sphereProgram.buf);
                gl.bufferData(gl.ARRAY_BUFFER, d, gl.DYNAMIC_DRAW);

                const st = 13 * 4; // 13 floats per vertex now
                gl.enableVertexAttribArray(sphereProgram.aPos);
                gl.vertexAttribPointer(sphereProgram.aPos, 2, gl.FLOAT, false, st, 0);
                gl.enableVertexAttribArray(sphereProgram.aCenter);
                gl.vertexAttribPointer(sphereProgram.aCenter, 2, gl.FLOAT, false, st, 8);
                gl.enableVertexAttribArray(sphereProgram.aRadius);
                gl.vertexAttribPointer(sphereProgram.aRadius, 1, gl.FLOAT, false, st, 16);
                gl.enableVertexAttribArray(sphereProgram.aColor);
                gl.vertexAttribPointer(sphereProgram.aColor, 3, gl.FLOAT, false, st, 20);
                gl.enableVertexAttribArray(sphereProgram.aAlpha);
                gl.vertexAttribPointer(sphereProgram.aAlpha, 1, gl.FLOAT, false, st, 32);
                gl.enableVertexAttribArray(sphereProgram.aAppear);
                gl.vertexAttribPointer(sphereProgram.aAppear, 1, gl.FLOAT, false, st, 36);
                gl.enableVertexAttribArray(sphereProgram.aGlow);
                gl.vertexAttribPointer(sphereProgram.aGlow, 1, gl.FLOAT, false, st, 40);
                gl.enableVertexAttribArray(sphereProgram.aIndex);
                gl.vertexAttribPointer(sphereProgram.aIndex, 1, gl.FLOAT, false, st, 44);
                gl.enableVertexAttribArray(sphereProgram.aIsLight);
                gl.vertexAttribPointer(sphereProgram.aIsLight, 1, gl.FLOAT, false, st, 48);

                // Draw based on actual vertex count (some nodes may be skipped)
                const vertexCount = v.length / 13;
                gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
                return true;
            }

            // Canvas 2D fallback
            function drawLitSphere(x, y, radius, baseColor, alpha, appearProgress, glow) {
                if (appearProgress < 0.01) return;
                const r = radius * appearProgress;
                if (r < 1) return;

                const cr = parseInt(baseColor.slice(1,3), 16);
                const cg = parseInt(baseColor.slice(3,5), 16);
                const cb = parseInt(baseColor.slice(5,7), 16);

                const lx = (mouseX - x) / (width || 1);
                const ly = (mouseY - y) / (height || 1);
                const ld = Math.sqrt(lx*lx + ly*ly) || 1;
                const hx = x - (lx/ld) * r * 0.35;
                const hy = y - (ly/ld) * r * 0.35;

                const grad = ctx.createRadialGradient(hx, hy, 0, x, y, r);
                grad.addColorStop(0, `rgba(${Math.min(255,cr+70)},${Math.min(255,cg+70)},${Math.min(255,cb+70)},${alpha})`);
                grad.addColorStop(0.35, `rgba(${cr},${cg},${cb},${alpha})`);
                grad.addColorStop(0.8, `rgba(${cr*0.55|0},${cg*0.55|0},${cb*0.55|0},${alpha})`);
                grad.addColorStop(1, `rgba(${cr*0.25|0},${cg*0.25|0},${cb*0.25|0},${alpha*0.85})`);

                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();

                // Specular
                const sg = ctx.createRadialGradient(hx, hy, 0, hx, hy, r*0.28);
                sg.addColorStop(0, `rgba(255,255,255,${alpha*0.75})`);
                sg.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.beginPath();
                ctx.arc(hx, hy, r*0.28, 0, Math.PI * 2);
                ctx.fillStyle = sg;
                ctx.fill();

                // Rim
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255,255,255,${alpha*0.18 + (glow||0)*0.35})`;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            // Track time for glow delays
            let lastHoveredNode = null;
            let hoverStartTime = 0;

            function draw() {
                ctx.clearRect(0, 0, width, height);
                time += 0.016;

                const connectedToHovered = hoveredNode ? getConnectedNodes(hoveredNode) : new Set();

                // Reset glow delay timer when hover changes
                if (hoveredNode !== lastHoveredNode) {
                    hoverStartTime = time;
                    lastHoveredNode = hoveredNode;
                }

                const timeSinceHover = time - hoverStartTime;

                // Update glow intensities and shrink with smooth transitions
                nodes.forEach(node => {
                    const isHovered = node === hoveredNode;
                    const isConnected = connectedToHovered.has(node.id);

                    // Set target glow intensity and shrink
                    if (isHovered) {
                        node.targetGlowIntensity = 1;
                        node.glowDelay = 0;
                        node.targetShrink = 1;
                    } else if (isConnected) {
                        node.targetGlowIntensity = 0.6;
                        node.glowDelay = 0.15;
                        node.targetShrink = 1;
                    } else if (hoveredNode) {
                        // Not connected to hovered - shrink away
                        node.targetGlowIntensity = 0;
                        node.glowDelay = 0;
                        node.targetShrink = 0;
                    } else {
                        // No hover - show all
                        node.targetGlowIntensity = 0;
                        node.glowDelay = 0;
                        node.targetShrink = 1;
                    }

                    // Smoothly interpolate glow intensity with delay
                    const effectiveTime = Math.max(0, timeSinceHover - node.glowDelay);
                    if (effectiveTime > 0 || node.targetGlowIntensity === 0) {
                        const lerpSpeed = node.targetGlowIntensity > node.glowIntensity ? 0.08 : 0.12;
                        node.glowIntensity += (node.targetGlowIntensity - node.glowIntensity) * lerpSpeed;
                    }

                    // Smoothly interpolate shrink
                    const shrinkSpeed = node.targetShrink > node.shrinkProgress ? 0.12 : 0.08;
                    node.shrinkProgress += (node.targetShrink - node.shrinkProgress) * shrinkSpeed;

                    // Clamp very small values
                    if (node.glowIntensity < 0.01) node.glowIntensity = 0;
                    if (node.shrinkProgress < 0.01) node.shrinkProgress = 0;
                    if (node.shrinkProgress > 0.99) node.shrinkProgress = 1;
                });

                // Apply floating animation - always active for interesting movement
                nodes.forEach(node => {
                    if (node === dragNode) return;

                    // Primary float (figure-8 pattern)
                    const floatX = Math.sin(time * node.floatSpeed + node.floatPhase) * node.floatRadius;
                    const floatY = Math.cos(time * node.floatSpeed * 0.7 + node.floatPhase) * node.floatRadius * 0.8;

                    // Secondary wobble (adds complexity)
                    const wobbleX = Math.sin(time * node.floatSpeed2 + node.floatPhase * 2.0) * node.floatRadius2;
                    const wobbleY = Math.cos(time * node.floatSpeed2 * 1.3 + node.floatPhase * 2.0) * node.floatRadius2;

                    // Micro orbit around base position
                    node.orbitAngle += node.orbitSpeed * 0.016;
                    const orbitX = Math.cos(node.orbitAngle) * node.orbitRadius;
                    const orbitY = Math.sin(node.orbitAngle) * node.orbitRadius * 0.6;

                    // Combine all movements
                    if (settled) {
                        node.x = node.baseX + floatX + wobbleX + orbitX;
                        node.y = node.baseY + floatY + wobbleY + orbitY;
                    } else {
                        // During simulation, just add subtle float
                        node.x += (floatX + wobbleX) * 0.02;
                        node.y += (floatY + wobbleY) * 0.02;
                    }

                    node.rotation += node.rotationSpeed;
                });

                // Draw connections with gradient and mouse light
                // By default only show connections involving Unity, C#, or HLSL
                const primaryNodes = new Set(['unity', 'csharp', 'hlsl']);
                connections.forEach(([a, b]) => {
                    const nodeA = nodes.find(n => n.id === a);
                    const nodeB = nodes.find(n => n.id === b);
                    if (!nodeA || !nodeB) return;

                    const isHighlighted = hoveredNode &&
                        (hoveredNode.id === a || hoveredNode.id === b);

                    // Get shrink progress of both nodes to fade connection
                    const shrinkA = nodeA.shrinkProgress !== undefined ? nodeA.shrinkProgress : 1;
                    const shrinkB = nodeB.shrinkProgress !== undefined ? nodeB.shrinkProgress : 1;
                    const connectionFade = Math.min(shrinkA, shrinkB) * globalFadeIn;

                    // Skip fully faded connections
                    if (connectionFade < 0.01) return;

                    if (isHighlighted) {
                        // Highlighted connection - warm gold gradient
                        const gradient = ctx.createLinearGradient(nodeA.x, nodeA.y, nodeB.x, nodeB.y);
                        const alpha = 0.8 * connectionFade;
                        gradient.addColorStop(0, `rgba(255, 170, 50, ${alpha})`);
                        gradient.addColorStop(0.5, `rgba(255, 220, 100, ${alpha})`);
                        gradient.addColorStop(1, `rgba(255, 170, 50, ${alpha})`);
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 2;
                    } else {
                        // Hide non-highlighted connections when hovering
                        if (hoveredNode) return;
                        // Only show primary connections by default
                        if (!primaryNodes.has(a) && !primaryNodes.has(b)) return;
                        // Default - subtle but visible
                        const baseAlpha = 0.055 * connectionFade;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${baseAlpha})`;
                        ctx.lineWidth = 0.5;
                    }

                    ctx.beginPath();
                    ctx.moveTo(nodeA.x, nodeA.y);
                    ctx.lineTo(nodeB.x, nodeB.y);
                    ctx.stroke();
                });

                // Draw nodes with WebGL PBR shader (falls back to Canvas 2D)
                if (!renderSpheresGL(nodes, hoveredNode, connectedToHovered)) {
                    // Canvas 2D fallback
                    nodes.forEach(node => {
                        const shrink = node.shrinkProgress !== undefined ? node.shrinkProgress : 1;
                        if (shrink < 0.01 || globalFadeIn < 0.01) return;

                        const pulse = Math.sin(time * node.pulseSpeed + node.pulsePhase);
                        const sizeBoost = node.glowIntensity * 3;
                        const displaySize = (node.size + pulse * 0.5 + sizeBoost) * shrink;

                        let baseColor;
                        if (node.category === 'primary') baseColor = colors.gold;
                        else if (node.category === 'secondary') baseColor = colors.teal;
                        else baseColor = colors.textMuted;

                        const alpha = shrink * globalFadeIn;
                        drawLitSphere(node.x, node.y, displaySize, baseColor, alpha, globalFadeIn * shrink, node.glowIntensity);
                    });
                }

                // Draw labels
                nodes.forEach(node => {
                    const isHovered = node === hoveredNode;
                    const isConnected = connectedToHovered.has(node.id);
                    const shrink = node.shrinkProgress !== undefined ? node.shrinkProgress : 1;

                    // Skip label if shrunk or not yet faded in
                    if (shrink < 0.1) return;
                    if (globalFadeIn < 0.5) return;

                    const labelAlpha = Math.min(1, (globalFadeIn - 0.5) * 2) * shrink;
                    const pulse = Math.sin(time * node.pulseSpeed + node.pulsePhase);
                    const sizeBoost = node.glowIntensity * 3;
                    const displaySize = (node.size + pulse * 0.5 + sizeBoost) * shrink;

                    // Label with background - smooth font weight transition, scaled for screen size
                    const labelOffset = 12 * sizeScale + 6;
                    const labelY = node.y + displaySize + labelOffset;
                    const fontWeight = node.glowIntensity > 0.5 ? '600' : '500';
                    const baseFontSize = 9.5 + 2.5 * sizeScale;
                    const fontSize = (baseFontSize + node.glowIntensity) * (0.7 + shrink * 0.3);
                    ctx.font = `${fontWeight} ${fontSize}px "JetBrains Mono", monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    const textWidth = ctx.measureText(node.label).width;
                    const paddingX = 3 * sizeScale + 1;
                    const paddingY = 5 * sizeScale + 2;

                    ctx.globalAlpha = labelAlpha;

                    // Label background
                    ctx.fillStyle = `rgba(21, 29, 38, ${0.8 * shrink})`;
                    ctx.beginPath();
                    ctx.roundRect(node.x - textWidth / 2 - paddingX, labelY - paddingY, textWidth + paddingX * 2, paddingY * 2, 3);
                    ctx.fill();

                    // Label text
                    ctx.fillStyle = colors.textPrimary;
                    ctx.fillText(node.label, node.x, labelY);

                    ctx.globalAlpha = 1;
                });

                // Draw tooltip connector line after nodes
                drawTooltipConnector();
            }

            function animate() {
                simulate();
                draw();
                updateShowcase();
                requestAnimationFrame(animate);
            }

            // Event handlers
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                dragNode = getNodeAt(mouseX, mouseY);
                if (dragNode) {
                    isDragging = true;
                    settled = false;
                    container.style.cursor = 'grabbing';
                    // If we're starting to drag a node that has tooltip, set it as target
                    if (hoveredNode === dragNode && !tooltipTarget) {
                        tooltipTarget = dragNode;
                        generateTooltipPosition(dragNode);
                    }
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;

                if (isDragging && dragNode) {
                    dragNode.x = mouseX;
                    dragNode.y = mouseY;
                    dragNode.baseX = mouseX;
                    dragNode.baseY = mouseY;
                    dragNode.vx = 0;
                    dragNode.vy = 0;
                    settled = false;
                    settleTimer = 0;
                    // Update tooltip position to follow the dragged node
                    if (tooltipTarget === dragNode) {
                        updateTooltipPositionForDrag(dragNode);
                    }
                } else {
                    hoveredNode = getNodeAt(mouseX, mouseY);
                    container.style.cursor = hoveredNode ? 'pointer' : 'grab';
                    updateTooltip(hoveredNode);
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                dragNode = null;
                container.style.cursor = hoveredNode ? 'pointer' : 'grab';
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                dragNode = null;
                hoveredNode = null;
                container.style.cursor = 'grab';
                updateTooltip(null);
            });

            // Touch support
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                mouseX = touch.clientX - rect.left;
                mouseY = touch.clientY - rect.top;
                dragNode = getNodeAt(mouseX, mouseY);
                if (dragNode) {
                    isDragging = true;
                    settled = false;
                    // Show tooltip for touched node
                    tooltipTarget = dragNode;
                    generateTooltipPosition(dragNode);
                    updateTooltip(dragNode);
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDragging || !dragNode) return;
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                dragNode.x = touch.clientX - rect.left;
                dragNode.y = touch.clientY - rect.top;
                dragNode.baseX = dragNode.x;
                dragNode.baseY = dragNode.y;
                dragNode.vx = 0;
                dragNode.vy = 0;
                settled = false;
                // Update tooltip position to follow the dragged node
                if (tooltipTarget === dragNode) {
                    updateTooltipPositionForDrag(dragNode);
                }
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                isDragging = false;
                dragNode = null;
            });

            // Initialize
            window.addEventListener('resize', resize);

            // Initialize WebGL sphere renderer
            initSphereGL();

            resize();

            // Initialize showcase timer (start after a short delay)
            lastShowcaseTime = performance.now();

            // Reset fade in when returning to tab
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    time = 0;
                    globalFadeIn = 0;
                    startupPhase = true;
                    lastShowcaseTime = performance.now();
                    // Hide any active tooltip/showcase
                    tooltip.classList.remove('visible');
                    tooltipTarget = null;
                    showcaseActive = false;
                    showcaseNode = null;
                }
            });

            // Reset fade in when switching to skills tab
            window.addEventListener('skillsTabActivated', () => {
                time = 0;
                globalFadeIn = 0;
                startupPhase = true;
                lastShowcaseTime = performance.now();
                // Hide any active tooltip/showcase
                tooltip.classList.remove('visible');
                tooltipTarget = null;
                showcaseActive = false;
                showcaseNode = null;
            });

            animate();
        })();

        // Counting animation for stats
        (function() {
            const stats = document.querySelectorAll('.stat-number[data-target]');

            stats.forEach((stat, index) => {
                const target = parseInt(stat.dataset.target);
                const suffix = stat.dataset.suffix || '';
                let current = 0;
                const duration = 1500; // ms
                const startDelay = 600 + index * 200; // Stagger start
                const stepTime = duration / target;

                setTimeout(() => {
                    const interval = setInterval(() => {
                        current++;
                        stat.textContent = current + (current === target ? suffix : '');

                        if (current >= target) {
                            clearInterval(interval);
                        }
                    }, stepTime);
                }, startDelay);
            });
        })();

        // Staggered reveal animation for clients and projects
        (function() {
            const clientCards = document.querySelectorAll('.client-card');
            const testimonialCards = document.querySelectorAll('.testimonial-card');
            const projectCards = document.querySelectorAll('.project-card');

            // Stagger client cards animation
            clientCards.forEach((card, i) => {
                card.style.animationDelay = `${0.6 + i * 0.08}s`;
            });

            // Stagger testimonial cards animation
            testimonialCards.forEach((card, i) => {
                card.style.animationDelay = `${0.6 + i * 0.15}s`;
            });

            // Stagger project cards animation
            projectCards.forEach((card, i) => {
                card.style.animationDelay = `${0.6 + i * 0.12}s`;
            });
        })();

        // 3D Curved Portfolio Carousel
        (function() {
            const items = document.querySelectorAll('.portfolio-item');
            const prevBtn = document.querySelector('.portfolio-nav.prev');
            const nextBtn = document.querySelector('.portfolio-nav.next');
            const titleEl = document.getElementById('portfolio-title');
            const linkEl = document.getElementById('portfolio-link');
            const dotsContainer = document.getElementById('portfolio-dots');
            const scene = document.querySelector('.portfolio-scene');

            if (!items.length) return;

            let currentIndex = 0;
            const totalItems = items.length;
            const visibleItems = 5; // Number of items visible at once

            // Create dots
            items.forEach((_, i) => {
                const dot = document.createElement('div');
                dot.className = 'portfolio-dot' + (i === 0 ? ' active' : '');
                dot.addEventListener('click', () => goToSlide(i));
                dotsContainer.appendChild(dot);
            });
            const dots = dotsContainer.querySelectorAll('.portfolio-dot');

            function updateCarousel() {
                const sceneRect = scene.getBoundingClientRect();
                const centerX = sceneRect.width / 2;
                const centerY = sceneRect.height / 2;

                // Responsive values based on screen width
                const isMobile = window.innerWidth <= 900;
                const isSmallMobile = window.innerWidth <= 480;

                // Adjust 3D parameters for mobile
                const spreadX = isSmallMobile ? 100 : (isMobile ? 130 : 180);
                const depthZ = isSmallMobile ? 80 : (isMobile ? 100 : 150);
                const rotationAngle = isSmallMobile ? 15 : (isMobile ? 20 : 25);
                const hiddenSpread = isSmallMobile ? 150 : (isMobile ? 200 : 300);

                items.forEach((item, i) => {
                    // Calculate position relative to current index
                    let offset = i - currentIndex;

                    // Wrap around for infinite loop feel
                    if (offset > totalItems / 2) offset -= totalItems;
                    if (offset < -totalItems / 2) offset += totalItems;

                    const absOffset = Math.abs(offset);

                    // Only show nearby items
                    if (absOffset > Math.floor(visibleItems / 2)) {
                        item.style.opacity = '0';
                        item.style.pointerEvents = 'none';
                        item.style.transform = `translate(-50%, -50%) translateX(${offset * hiddenSpread}px) translateZ(-500px) scale(0.5)`;
                        return;
                    }

                    // 3D positioning on a curve
                    const angle = offset * rotationAngle; // Degrees of rotation
                    const translateX = offset * spreadX; // Horizontal spread
                    const translateZ = -Math.abs(offset) * depthZ; // Depth
                    const scale = 1 - absOffset * 0.15;
                    const opacity = 1 - absOffset * 0.3;

                    item.style.transform = `
                        translate(-50%, -50%)
                        translateX(${translateX}px)
                        translateZ(${translateZ}px)
                        rotateY(${-angle}deg)
                        scale(${scale})
                    `;
                    item.style.opacity = opacity;
                    item.style.zIndex = visibleItems - absOffset;
                    item.style.pointerEvents = offset === 0 ? 'auto' : 'none';
                    item.classList.toggle('active', offset === 0);
                });

                // Update title and link
                const activeItem = items[currentIndex];
                if (titleEl) titleEl.textContent = activeItem.dataset.title;
                if (linkEl) {
                    const url = activeItem.dataset.url;
                    linkEl.href = url;
                    linkEl.style.display = url ? '' : 'none';
                }

                // Update dots
                dots.forEach((dot, i) => {
                    dot.classList.toggle('active', i === currentIndex);
                });
            }

            function goToSlide(index) {
                if (index < 0) index = totalItems - 1;
                if (index >= totalItems) index = 0;
                currentIndex = index;
                updateCarousel();
            }

            // Navigation
            if (prevBtn) prevBtn.addEventListener('click', () => goToSlide(currentIndex - 1));
            if (nextBtn) nextBtn.addEventListener('click', () => goToSlide(currentIndex + 1));

            // Click on items to navigate
            items.forEach((item, i) => {
                item.addEventListener('click', () => {
                    if (i === currentIndex) {
                        // Open link if clicking active item
                        window.open(item.dataset.url, '_blank');
                    } else {
                        goToSlide(i);
                    }
                });
            });

            // Keyboard navigation
            document.addEventListener('keydown', (e) => {
                const portfolioPanel = document.getElementById('panel-portfolio');
                if (!portfolioPanel || !portfolioPanel.classList.contains('active')) return;

                if (e.key === 'ArrowLeft') goToSlide(currentIndex - 1);
                if (e.key === 'ArrowRight') goToSlide(currentIndex + 1);
            });

            // Touch swipe support
            let touchStartX = 0;
            if (scene) {
                scene.addEventListener('touchstart', (e) => {
                    touchStartX = e.changedTouches[0].screenX;
                }, { passive: true });

                scene.addEventListener('touchend', (e) => {
                    const diff = touchStartX - e.changedTouches[0].screenX;
                    if (Math.abs(diff) > 50) {
                        if (diff > 0) goToSlide(currentIndex + 1);
                        else goToSlide(currentIndex - 1);
                    }
                }, { passive: true });
            }

            // Mouse wheel navigation
            if (scene) {
                scene.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    if (e.deltaY > 0) goToSlide(currentIndex + 1);
                    else goToSlide(currentIndex - 1);
                }, { passive: false });
            }

            // Update on resize (for orientation changes)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(updateCarousel, 100);
            });

            // Initial setup
            updateCarousel();
        })();

        // Typewriter effect with typos
        (function() {
            const container = document.getElementById('typewriter-container');
            const typingIndicator = document.getElementById('typing-indicator');
            const dots = typingIndicator ? typingIndicator.querySelectorAll('.typing-dots span') : [];
            if (!container) return;

            const fullText = [
                { text: 'I run ', highlight: false },
                { text: 'Zylaris Ltd', highlight: true },
                { text: ', a specialized consultancy delivering high-performance graphics solutions for games, VR, and immersive installations. From ', highlight: false },
                { text: 'GPU-based light baking', highlight: true },
                { text: ' using SDFs to ', highlight: false },
                { text: '16K projection-mapped environments', highlight: true },
                { text: ', I help studios push the boundaries of real-time rendering across mobile, desktop, VR, and web platforms. I\'ve shipped graphics systems for studios including ', highlight: false },
                { text: 'Nexus', highlight: true },
                { text: ', ', highlight: false },
                { text: 'Ubisoft', highlight: true },
                { text: ', ', highlight: false },
                { text: '22cans', highlight: true },
                { text: ', and ', highlight: false },
                { text: 'The Sandbox', highlight: true },
                { text: '.', highlight: false }
            ];

            // Define typos: [position in full string, wrong char, correct char]
            const typos = [
                { pos: 15, wrong: 'x', correct: 'c' },      // "speciaxized" -> "specialized"
                { pos: 78, wrong: 'f', correct: 'g' },      // "fames" -> "games"
                { pos: 142, wrong: 'b', correct: 'p' },     // "berformance" -> "performance"
                { pos: 245, wrong: 'r', correct: 't' },     // "srudios" -> "studios"
            ];

            let cursor = document.createElement('span');
            cursor.className = 'typewriter-cursor';
            container.appendChild(cursor);

            let globalPos = 0;
            let segmentIndex = 0;
            let charIndex = 0;
            let currentSpan = null;
            let typoQueue = [...typos].sort((a, b) => a.pos - b.pos);
            let isDeleting = false;
            let deleteCount = 0;
            let typoChar = null;
            let dotIndex = 0;
            let dotInterval = null;

            // Animate dots: 0 -> 1 -> 2 -> 3 -> 0 -> 1 -> 2 -> 3
            function animateDots() {
                if (!dots.length) return;

                // Reset all dots
                dots.forEach((dot, i) => {
                    dot.classList.toggle('visible', i < dotIndex);
                });

                dotIndex++;
                if (dotIndex > 3) dotIndex = 0;
            }

            // Start dot animation
            dotInterval = setInterval(animateDots, 300);

            function getBaseDelay() {
                return 12 + Math.random() * 18; // Faster: was 25-60, now 12-30
            }

            function finishTyping() {
                cursor.classList.add('hidden');
                if (typingIndicator) {
                    typingIndicator.classList.add('hidden');
                }
                if (dotInterval) {
                    clearInterval(dotInterval);
                }
            }

            function type() {
                if (segmentIndex >= fullText.length) {
                    finishTyping();
                    return;
                }

                const segment = fullText[segmentIndex];

                // Create span for new segment
                if (!currentSpan) {
                    currentSpan = document.createElement('span');
                    if (segment.highlight) {
                        currentSpan.className = 'highlight-text';
                    }
                    container.insertBefore(currentSpan, cursor);
                }

                // Check for typo at current position
                const currentTypo = typoQueue[0];
                if (currentTypo && globalPos === currentTypo.pos && !isDeleting && !typoChar) {
                    // Type wrong character
                    typoChar = document.createElement('span');
                    typoChar.className = 'typo-char';
                    typoChar.textContent = currentTypo.wrong;
                    currentSpan.appendChild(typoChar);
                    globalPos++;
                    charIndex++;

                    // Schedule delete after brief pause
                    setTimeout(() => {
                        isDeleting = true;
                        deleteCount = 1;
                        setTimeout(type, 80 + Math.random() * 50);
                    }, 120 + Math.random() * 80);
                    return;
                }

                // Handle deleting typo
                if (isDeleting && deleteCount > 0) {
                    if (typoChar) {
                        typoChar.remove();
                        typoChar = null;
                    }
                    globalPos--;
                    charIndex--;
                    deleteCount--;
                    isDeleting = false;
                    typoQueue.shift(); // Remove processed typo
                    setTimeout(type, 50);
                    return;
                }

                // Normal typing
                if (charIndex < segment.text.length) {
                    currentSpan.textContent += segment.text[charIndex];
                    charIndex++;
                    globalPos++;

                    // Variable delay - slower for punctuation
                    let delay = getBaseDelay();
                    const char = segment.text[charIndex - 1];
                    if (['.', ',', '!', '?'].includes(char)) {
                        delay += 80 + Math.random() * 60;
                    } else if (char === ' ') {
                        delay += Math.random() * 15;
                    }

                    setTimeout(type, delay);
                } else {
                    // Move to next segment
                    segmentIndex++;
                    charIndex = 0;
                    currentSpan = null;
                    setTimeout(type, getBaseDelay());
                }
            }

            // Start after a delay
            setTimeout(type, 500);
        })();

        // Project List Scroll Handler
        (function() {
            const wrapper = document.getElementById('project-list-wrapper');
            const list = document.getElementById('project-list');
            const hint = wrapper ? wrapper.querySelector('.scroll-hint') : null;
            if (!wrapper || !list) return;

            function updateScrollState() {
                const scrollPos = list.scrollTop;
                const maxScroll = list.scrollHeight - list.clientHeight;

                // Remove all scroll state classes
                wrapper.classList.remove('scrolled-top', 'scrolled-middle', 'scrolled-end');

                if (scrollPos <= 10) {
                    // At top - no top fade, show bottom fade
                    wrapper.classList.add('scrolled-top');
                    if (hint) hint.style.opacity = '0.7';
                } else if (scrollPos >= maxScroll - 10) {
                    // At bottom - show top fade, no bottom fade
                    wrapper.classList.add('scrolled-end');
                    if (hint) hint.style.opacity = '0';
                } else {
                    // In middle - show both fades
                    wrapper.classList.add('scrolled-middle');
                    if (hint) hint.style.opacity = '0.5';
                }
            }

            list.addEventListener('scroll', updateScrollState);
            updateScrollState(); // Initial state
        })();

        // Tabbed Carousel
        (function() {
            const tabs = document.querySelectorAll('.carousel-tab');
            const panels = document.querySelectorAll('.carousel-panel');

            if (!tabs.length || !panels.length) return;

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const panelId = tab.dataset.panel;

                    // Update active tab
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    // Update active panel with animation
                    panels.forEach(panel => {
                        if (panel.id === `panel-${panelId}`) {
                            panel.classList.add('active');
                            // Re-trigger animations for elements in this panel
                            triggerPanelAnimations(panel);
                        } else {
                            panel.classList.remove('active');
                        }
                    });

                    // Reinitialize skill graph canvas if switching to skills panel
                    if (panelId === 'skills') {
                        const canvas = document.getElementById('skill-graph-canvas');
                        if (canvas) {
                            // Reset fade animation and trigger resize
                            window.dispatchEvent(new Event('skillsTabActivated'));
                            window.dispatchEvent(new Event('resize'));
                        }
                    }
                });
            });

            function triggerPanelAnimations(panel) {
                // Reset and re-trigger animations for client cards
                const clientCards = panel.querySelectorAll('.client-card');
                clientCards.forEach((card, i) => {
                    card.style.animation = 'none';
                    card.offsetHeight; // Trigger reflow
                    card.style.animation = '';
                    card.style.animationDelay = `${i * 0.08}s`;
                });

                // Reset and re-trigger animations for testimonial cards
                const testimonialCards = panel.querySelectorAll('.testimonial-card');
                testimonialCards.forEach((card, i) => {
                    card.style.animation = 'none';
                    card.offsetHeight; // Trigger reflow
                    card.style.animation = '';
                    card.style.animationDelay = `${i * 0.15}s`;
                });

                // Reset and re-trigger animations for project cards
                const projectCards = panel.querySelectorAll('.project-card');
                projectCards.forEach((card, i) => {
                    card.style.animation = 'none';
                    card.offsetHeight; // Trigger reflow
                    card.style.animation = '';
                    card.style.animationDelay = `${i * 0.12}s`;
                });

                // Reset and re-trigger animation for portfolio carousel
                const portfolioCarousel = panel.querySelector('.portfolio-carousel');
                if (portfolioCarousel) {
                    portfolioCarousel.style.animation = 'none';
                    portfolioCarousel.offsetHeight; // Trigger reflow
                    portfolioCarousel.style.animation = '';
                }
            }
        })();

        // ============================================
        // ANIMATED FAVICON - Breathing Dot
        // ============================================
        (function() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const link = document.getElementById('favicon');

            let time = 0;
            const gold = '#e8b923';

            function draw() {
                ctx.clearRect(0, 0, 32, 32);

                const cx = 16;
                const cy = 16;

                // Smooth breathing animation
                const pulse = Math.sin(time) * 0.2 + 0.8;
                const radius = 9 * pulse;

                // Soft glow
                const gradient = ctx.createRadialGradient(cx, cy, radius * 0.5, cx, cy, radius + 3);
                gradient.addColorStop(0, gold);
                gradient.addColorStop(0.7, 'rgba(232, 185, 35, 0.4)');
                gradient.addColorStop(1, 'transparent');

                ctx.beginPath();
                ctx.arc(cx, cy, radius + 3, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Core dot
                ctx.beginPath();
                ctx.arc(cx, cy, radius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = gold;
                ctx.fill();

                link.href = canvas.toDataURL('image/png');
            }

            function animate() {
                time += 0.04;
                draw();
                requestAnimationFrame(animate);
            }

            animate();
        })();

        // ============================================
        // FPS PERFORMANCE COUNTER
        // ============================================
        (function() {
            const fpsBadge = document.getElementById('fps-badge');
            const fpsValue = document.getElementById('fps-value');

            if (!fpsBadge || !fpsValue) return;

            let frameCount = 0;
            let lastTime = performance.now();
            let fps = 60;

            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                const elapsed = currentTime - lastTime;

                // Update every 500ms for smoother display
                if (elapsed >= 500) {
                    fps = Math.round((frameCount * 1000) / elapsed);
                    frameCount = 0;
                    lastTime = currentTime;

                    // Update display
                    fpsValue.textContent = fps;

                    // Update badge class based on performance
                    fpsBadge.classList.remove('good', 'warn', 'bad');
                    if (fps >= 50) {
                        fpsBadge.classList.add('good');
                    } else if (fps >= 30) {
                        fpsBadge.classList.add('warn');
                    } else {
                        fpsBadge.classList.add('bad');
                    }
                }

                requestAnimationFrame(updateFPS);
            }

            // Start FPS monitoring
            requestAnimationFrame(updateFPS);
        })();
    </script>
</body>
</html>