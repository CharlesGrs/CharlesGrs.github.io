<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Charles Grassi | Graphics Programmer & Technical Artist</title>
    <link rel="icon" type="image/png" id="favicon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABISURBVFhH7c0xAQAgDMCwgX/PYAdxdkGxSPquzj47AAAAAAAAAADABw+wAAuwAAuwAAuwAAuwAAuwAAuwAAuwAAuwAAsw1HUBKABKOl4R5FAAAAAASUVORK5CYII=">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --bg-primary: #0a0f14;
            --bg-secondary: #111921;
            --bg-card: #151d26;
            --accent-gold: #e8b923;
            --accent-gold-dim: #c49a1a;
            --accent-teal: #2dd4bf;
            --text-primary: #e8eaed;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --border-color: #1f2937;
            --gradient-mesh: radial-gradient(ellipse 120% 100% at 20% 0%, rgba(232, 185, 35, 0.05) 0%, rgba(232, 185, 35, 0.02) 30%, transparent 70%), radial-gradient(ellipse 100% 80% at 80% 100%, rgba(45, 212, 191, 0.03) 0%, rgba(45, 212, 191, 0.01) 30%, transparent 70%);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        #gpu-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .contact-btn {
            position: fixed;
            top: 2rem;
            right: 2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-gold-dim) 100%);
            border: none;
            border-radius: 6px;
            color: var(--bg-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 4px 15px rgba(232, 185, 35, 0.3);
        }

            .contact-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 25px rgba(232, 185, 35, 0.5);
            }

            .contact-btn:active {
                transform: translateY(0);
            }

            .contact-btn svg {
                width: 16px;
                height: 16px;
            }

        @media print {
            .contact-btn {
                display: none !important;
            }
        }

        @media (max-width: 900px) {
            .contact-btn {
                top: 1rem;
                right: 1rem;
                padding: 0.6rem 1rem;
                font-size: 0.75rem;
            }
        }

        .noise-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.03;
            z-index: 1000;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* FPS Performance Badge */
        .fps-badge {
            position: fixed;
            bottom: 1.5rem;
            left: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: rgba(21, 29, 38, 0.85);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            z-index: 100;
            transition: all 0.3s ease;
            cursor: default;
            user-select: none;
        }

        .fps-badge:hover {
            border-color: var(--accent-teal);
            color: var(--text-secondary);
        }

        .fps-badge .fps-icon {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-teal);
            box-shadow: 0 0 6px rgba(45, 212, 191, 0.5);
            animation: fpsPulse 2s ease-in-out infinite;
        }

        .fps-badge.good .fps-icon {
            background: var(--accent-teal);
            box-shadow: 0 0 6px rgba(45, 212, 191, 0.5);
        }

        .fps-badge.warn .fps-icon {
            background: var(--accent-gold);
            box-shadow: 0 0 6px rgba(232, 185, 35, 0.5);
        }

        .fps-badge.bad .fps-icon {
            background: #ef4444;
            box-shadow: 0 0 6px rgba(239, 68, 68, 0.5);
        }

        @keyframes fpsPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.9); }
        }

        .fps-badge .fps-value {
            font-weight: 600;
            color: var(--accent-teal);
            min-width: 2ch;
            text-align: right;
        }

        .fps-badge.warn .fps-value {
            color: var(--accent-gold);
        }

        .fps-badge.bad .fps-value {
            color: #ef4444;
        }

        .fps-badge .fps-label {
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        @media (max-width: 900px) {
            .fps-badge {
                bottom: 1rem;
                left: 1rem;
                padding: 0.4rem 0.6rem;
                font-size: 0.6rem;
            }
        }

        @media print {
            .fps-badge {
                display: none !important;
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 2rem 1.5rem;
            background: transparent;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

            .container::before {
                content: '';
                position: absolute;
                top: 0;
                left: 50%;
                transform: translateX(-50%);
                width: 100vw;
                height: 100%;
                background: radial-gradient(ellipse 120% 100% at 20% 0%, rgba(232, 185, 35, 0.05) 0%, rgba(232, 185, 35, 0.02) 30%, transparent 70%), radial-gradient(ellipse 100% 80% at 80% 50%, rgba(45, 212, 191, 0.03) 0%, rgba(45, 212, 191, 0.01) 30%, transparent 70%);
                pointer-events: none;
                z-index: -1;
            }

        /* Header */
        header {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 1rem;
            animation: fadeInUp 0.6s ease-out;
            flex-shrink: 0;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .name-block h1 {
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: -0.03em;
            line-height: 1;
            margin-bottom: 0.4rem;
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-gold-dim) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .tagline {
            font-size: 0.95rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            font-weight: 300;
        }

        .titles {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .title-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 500;
            padding: 0.4rem 0.8rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

            .title-tag.highlight {
                border-color: var(--accent-gold);
                color: var(--accent-gold);
            }

        .contact-block {
            text-align: right;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

            .contact-block a {
                color: var(--text-secondary);
                text-decoration: none;
                display: block;
                padding: 0.3rem 0;
                transition: color 0.2s ease;
            }

                .contact-block a:hover {
                    color: var(--accent-teal);
                }

            .contact-block .company {
                color: var(--accent-gold);
                font-weight: 500;
                margin-bottom: 0.5rem;
            }

        .languages {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        .lang {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-muted);
        }

        /* Reveal Animations */
        @keyframes skillReveal {
            0% {
                opacity: 0;
                transform: scale(0.8);
                filter: brightness(1);
                box-shadow: none;
            }
            50% {
                filter: brightness(1.8);
                box-shadow: 0 0 20px rgba(45, 212, 191, 0.6);
            }
            100% {
                opacity: 1;
                transform: scale(1);
                filter: brightness(1);
                box-shadow: none;
            }
        }

        @keyframes skillRevealGold {
            0% {
                opacity: 0;
                transform: scale(0.8);
                filter: brightness(1);
                box-shadow: none;
            }
            50% {
                filter: brightness(2);
                box-shadow: 0 0 25px rgba(232, 185, 35, 0.7);
            }
            100% {
                opacity: 1;
                transform: scale(1);
                filter: brightness(1);
                box-shadow: none;
            }
        }

        /* Summary Section with Stats */
        .summary-row {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1rem;
            align-items: stretch;
            flex-shrink: 0;
        }

        .summary {
            flex: 1;
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.5) 0%, rgba(21, 29, 38, 0.2) 70%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
            padding: 1.5rem;
        }

        .stats-bar {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 0.75rem;
            padding: 1rem 1.5rem;
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.5) 0%, rgba(21, 29, 38, 0.2) 70%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
            animation: fadeInUp 0.6s ease-out 0.15s backwards;
        }

        .stat-item {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-gold);
            line-height: 1;
            font-family: 'JetBrains Mono', monospace;
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

            .summary p {
                color: var(--text-secondary);
                font-size: 0.85rem;
                line-height: 1.7;
            }

            .summary .highlight-text {
                color: var(--accent-gold);
                font-weight: 500;
            }

        /* Typewriter effect */
        .typewriter-text {
            position: relative;
        }

        .typewriter-cursor {
            display: inline-block;
            width: 2px;
            height: 1.1em;
            background: var(--accent-gold);
            margin-left: 2px;
            vertical-align: text-bottom;
            animation: cursorBlink 0.6s infinite;
        }

        .typewriter-cursor.hidden {
            opacity: 0;
            animation: none;
        }

        @keyframes cursorBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .typo-char {
            color: var(--accent-teal);
            opacity: 0.7;
        }

        .typing-indicator {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            position: absolute;
            bottom: -1.5rem;
            left: 0;
            opacity: 0.6;
        }

        .typing-indicator.hidden {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .summary {
            position: relative;
        }

        .typing-dots {
            display: inline;
        }

        .typing-dots span {
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .typing-dots span.visible {
            opacity: 1;
        }

        /* Project List - Timeline Style */
        .project-list-wrapper {
            position: relative;
            overflow: hidden;
            flex: 1;
        }

        .project-list {
            display: flex;
            flex-direction: column;
            gap: 0;
            height: 100%;
            overflow-y: auto;
            padding-right: 0.5rem;
            scroll-behavior: smooth;
        }

        /* Custom scrollbar */
        .project-list::-webkit-scrollbar {
            width: 3px;
        }

        .project-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .project-list::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 2px;
        }

        .project-list::-webkit-scrollbar-thumb:hover {
            background: var(--accent-gold);
        }

        /* Fade hints at top and bottom */
        .project-list-wrapper::before,
        .project-list-wrapper::after {
            content: '';
            position: absolute;
            left: 0;
            right: 8px;
            height: 40px;
            pointer-events: none;
            z-index: 2;
            transition: opacity 0.3s ease;
        }

        .project-list-wrapper::before {
            top: 0;
            background: linear-gradient(to bottom, var(--bg-primary), transparent);
            opacity: 0;
        }

        .project-list-wrapper::after {
            bottom: 0;
            background: linear-gradient(to top, var(--bg-primary), transparent);
            opacity: 1;
        }

        .project-list-wrapper.scrolled-top::before {
            opacity: 0;
        }

        .project-list-wrapper.scrolled-middle::before,
        .project-list-wrapper.scrolled-middle::after {
            opacity: 1;
        }

        .project-list-wrapper.scrolled-end::after {
            opacity: 0;
        }

        .project-card {
            position: relative;
            padding: 0.85rem 0 0.85rem 1rem;
            background: transparent;
            border: none;
            border-left: 2px solid var(--border-color);
            margin-left: 0.5rem;
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateX(-10px);
            animation: projectReveal 0.5s ease forwards;
        }

        .project-card::before {
            content: '';
            position: absolute;
            left: -5px;
            top: 1.1rem;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border-color);
            border: 2px solid var(--bg-primary);
            transition: all 0.3s ease;
        }

        @keyframes projectReveal {
            0% {
                opacity: 0;
                transform: translateX(-10px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .project-card:hover {
            border-left-color: var(--accent-gold);
        }

        .project-card:hover::before {
            background: var(--accent-gold);
            box-shadow: 0 0 10px rgba(232, 185, 35, 0.5);
        }

        .project-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.3rem;
            gap: 0.5rem;
        }

        .project-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            line-height: 1.3;
        }

        .project-client {
            font-size: 0.75rem;
            color: var(--accent-teal);
            font-weight: 500;
        }

        .project-year {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .project-desc {
            color: var(--text-secondary);
            font-size: 0.75rem;
            line-height: 1.5;
            margin-top: 0.25rem;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .project-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-top: 0.4rem;
        }

        .tech-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.55rem;
            padding: 0.15rem 0.4rem;
            background: transparent;
            border: 1px solid var(--accent-teal);
            border-radius: 3px;
            color: var(--accent-teal);
            opacity: 0.8;
        }

        /* Leadership card highlight */
        .leadership-card {
            border-left-color: var(--accent-gold);
        }

        .leadership-card::before {
            background: var(--accent-gold);
        }

        .leadership-card .project-title {
            color: var(--accent-gold);
        }

        .leadership-card .tech-tag {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        /* Scroll hint text */
        .scroll-hint {
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 0.5rem;
            opacity: 0.5;
        }

        /* Tabbed Carousel Section */
        .tabbed-carousel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            animation: fadeInUp 0.6s ease-out 0.3s backwards;
        }

        .carousel-tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .carousel-tab {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 500;
            padding: 0.6rem 1.2rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .carousel-tab:hover {
            border-color: var(--accent-teal);
            color: var(--text-primary);
        }

        .carousel-tab.active {
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-gold-dim) 100%);
            border-color: var(--accent-gold);
            color: var(--bg-primary);
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(232, 185, 35, 0.3);
        }

        .carousel-panels {
            position: relative;
            flex: 1;
            min-height: 0;
        }

        .carousel-panel {
            display: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            height: 100%;
        }

        .carousel-panel.active {
            display: flex;
            flex-direction: column;
            opacity: 1;
            transform: translateY(0);
        }

        /* Skills Panel - Network Graph */
        .skills-panel .skill-graph-container {
            margin: 0;
            flex: 1;
            height: auto;
            background: transparent;
            border: none;
            backdrop-filter: none;
            -webkit-backdrop-filter: none;
        }

        .skills-panel .graph-legend,
        .skills-panel .graph-hint {
            display: none;
        }

        /* Career Panel - Timeline */
        .career-panel {
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.4) 0%, rgba(21, 29, 38, 0.15) 60%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
            padding: 1.5rem;
        }

        .career-panel .project-list-wrapper {
            flex: 1;
            max-height: none;
        }

        .career-panel .project-list {
            max-height: 100%;
            height: 100%;
        }

        /* Clients Panel */
        .clients-panel {
            padding: 2rem;
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.4) 0%, rgba(21, 29, 38, 0.15) 60%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
            flex: 1;
            overflow-y: auto;
        }

        .clients-panel .clients-section {
            margin-bottom: 2rem;
        }

        .clients-panel .clients-section:last-child {
            margin-bottom: 0;
        }

        .clients-panel .section-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .clients-panel .section-label::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-gold);
        }

        .clients-panel .section-label.other::before {
            background: var(--accent-teal);
        }

        .clients-panel .client-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .clients-panel .client-card {
            padding: 0.9rem 1.4rem;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 100px;
            text-align: left;
            text-decoration: none;
            transition: border-color 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                        transform 0.4s cubic-bezier(0.4, 0, 0.2, 1),
                        box-shadow 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: scale(0.9);
            animation: skillReveal 0.5s ease forwards;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            position: relative;
            overflow: hidden;
        }

        .clients-panel .client-card::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at center, rgba(45, 212, 191, 0.15) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .clients-panel .client-card:hover {
            border-color: var(--accent-teal);
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(45, 212, 191, 0.12);
        }

        .clients-panel .client-card:hover::before {
            opacity: 1;
            transition: opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1) 0.15s;
        }

        .clients-panel .client-card.major {
            border-color: rgba(232, 185, 35, 0.4);
            animation-name: skillRevealGold;
        }

        .clients-panel .client-card.major::before {
            background: radial-gradient(ellipse at center, rgba(232, 185, 35, 0.18) 0%, transparent 70%);
        }

        .clients-panel .client-card.major:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 4px 20px rgba(232, 185, 35, 0.15);
        }

        .clients-panel .client-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            position: relative;
            z-index: 1;
            transition: color 0.3s cubic-bezier(0.4, 0, 0.2, 1) 0.1s;
        }

        .clients-panel .client-card:hover .client-name {
            color: var(--accent-teal);
            transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1) 0.2s;
        }

        .clients-panel .client-card.major .client-name {
            color: var(--accent-gold);
        }

        .clients-panel .client-card.major:hover .client-name {
            color: #f5d060;
            transition: color 0.4s cubic-bezier(0.4, 0, 0.2, 1) 0.2s;
        }

        .clients-panel .client-type {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
            white-space: nowrap;
            position: relative;
            z-index: 1;
            padding: 0.2rem 0.5rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            transition: background 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                        color 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .clients-panel .client-card:hover .client-type {
            background: rgba(45, 212, 191, 0.15);
            color: var(--accent-teal);
            transition: background 0.4s cubic-bezier(0.4, 0, 0.2, 1) 0.25s,
                        color 0.4s cubic-bezier(0.4, 0, 0.2, 1) 0.25s;
        }

        .clients-panel .client-card.major .client-type {
            background: rgba(232, 185, 35, 0.1);
            color: var(--accent-gold);
        }

        .clients-panel .client-card.major:hover .client-type {
            background: rgba(232, 185, 35, 0.2);
            color: #f5d060;
            transition: background 0.4s cubic-bezier(0.4, 0, 0.2, 1) 0.25s,
                        color 0.4s cubic-bezier(0.4, 0, 0.2, 1) 0.25s;
        }

        /* Portfolio Panel */
        .portfolio-panel {
            padding: 1.5rem;
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.4) 0%, rgba(21, 29, 38, 0.15) 60%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
            overflow: hidden;
        }

        .portfolio-panel.active {
            display: flex;
            flex-direction: column;
        }

        .portfolio-carousel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .portfolio-main {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
            margin-bottom: 1rem;
        }

        .portfolio-slide {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
        }

        .portfolio-slide.active {
            opacity: 1;
            pointer-events: auto;
        }

        .portfolio-slide a {
            display: block;
            max-width: 100%;
            max-height: 100%;
        }

        .portfolio-slide img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .portfolio-slide a:hover img {
            transform: scale(1.02);
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.5);
        }

        .portfolio-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 0.75rem 1rem;
            background: transparent;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .portfolio-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .portfolio-link {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: var(--accent-teal);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .portfolio-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            background: rgba(21, 29, 38, 0.8);
            backdrop-filter: blur(8px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-secondary);
            z-index: 10;
        }

        .portfolio-nav:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            background: rgba(232, 185, 35, 0.1);
        }

        .portfolio-nav.prev {
            left: 0.5rem;
        }

        .portfolio-nav.next {
            right: 0.5rem;
        }

        .portfolio-nav svg {
            width: 20px;
            height: 20px;
        }

        .portfolio-thumbnails {
            display: flex;
            gap: 0.5rem;
            overflow-x: auto;
            padding: 0.5rem 0;
            scrollbar-width: thin;
            scrollbar-color: var(--border-color) transparent;
        }

        .portfolio-thumbnails::-webkit-scrollbar {
            height: 4px;
        }

        .portfolio-thumbnails::-webkit-scrollbar-track {
            background: transparent;
        }

        .portfolio-thumbnails::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 2px;
        }

        .portfolio-thumb {
            flex-shrink: 0;
            width: 60px;
            height: 60px;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            opacity: 0.6;
        }

        .portfolio-thumb:hover {
            opacity: 1;
        }

        .portfolio-thumb.active {
            border-color: var(--accent-gold);
            opacity: 1;
        }

        .portfolio-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .portfolio-counter {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            text-align: center;
            margin-top: 0.5rem;
        }

        /* Testimonials Panel */
        .testimonials-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            background: radial-gradient(ellipse at center, rgba(21, 29, 38, 0.4) 0%, rgba(21, 29, 38, 0.15) 60%, transparent 100%);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: none;
            border-radius: 16px;
        }

        .testimonial-card {
            padding: 1.5rem;
            background: linear-gradient(135deg, var(--bg-card) 0%, rgba(232, 185, 35, 0.03) 100%);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            position: relative;
            opacity: 0;
            transform: translateX(-10px);
            animation: projectReveal 0.5s ease forwards;
        }

        .testimonial-card::before {
            content: '"';
            position: absolute;
            top: 0.5rem;
            left: 1rem;
            font-size: 3rem;
            font-family: Georgia, serif;
            color: var(--accent-gold);
            opacity: 0.3;
            line-height: 1;
        }

        .testimonial-quote {
            font-size: 0.95rem;
            color: var(--text-secondary);
            line-height: 1.7;
            font-style: italic;
            margin-bottom: 1rem;
            padding-left: 1.5rem;
        }

        .testimonial-author {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding-left: 1.5rem;
        }

        .testimonial-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-teal) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.8rem;
            color: var(--bg-primary);
        }

        .testimonial-info {
            display: flex;
            flex-direction: column;
        }

        .testimonial-name {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .testimonial-role {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        /* Skill Graph */
        .skill-graph-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 250px;
            background: rgba(21, 29, 38, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
            cursor: grab;
        }

        .skill-graph-container:active {
            cursor: grabbing;
        }

        #skill-graph-canvas {
            width: 100%;
            height: 100%;
        }

        .graph-legend {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            display: flex;
            gap: 1.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .legend-dot.primary { background: var(--accent-gold); }
        .legend-dot.secondary { background: var(--accent-teal); }
        .legend-dot.tool { background: var(--text-muted); }

        .graph-hint {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
            opacity: 0.7;
        }

        .skill-tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(21, 29, 38, 0.95);
            border: 1px solid var(--accent-teal);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            width: 260px;
            opacity: 0;
            transition: opacity 0.25s ease;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .skill-tooltip.visible {
            opacity: 1;
        }

        .skill-tooltip.primary {
            border-color: var(--accent-gold);
        }

        .skill-tooltip.tool {
            border-color: var(--text-muted);
        }

        .skill-tooltip-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-gold);
            margin-bottom: 0.25rem;
        }

        .skill-tooltip.secondary .skill-tooltip-title {
            color: var(--accent-teal);
        }

        .skill-tooltip.tool .skill-tooltip-title {
            color: var(--text-secondary);
        }

        .skill-tooltip-desc {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .skill-tooltip-usage {
            font-size: 0.7rem;
            color: var(--text-muted);
            line-height: 1.5;
            border-top: 1px solid var(--border-color);
            padding-top: 0.5rem;
        }

        @media (max-width: 900px) {
            .skill-graph-container {
                height: 320px;
            }
        }

        /* Footer - Hidden for 100vh layout */
        footer {
            display: none;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 1rem;
        }

            .footer-links a {
                font-family: 'JetBrains Mono', monospace;
                font-size: 0.8rem;
                color: var(--text-muted);
                text-decoration: none;
                transition: color 0.2s ease;
            }

                .footer-links a:hover {
                    color: var(--accent-teal);
                }

        .footer-note {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 900px) {
            .container {
                padding: 1rem;
                height: auto;
                min-height: 100vh;
            }

            header {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .contact-block {
                text-align: left;
            }

            .languages {
                justify-content: flex-start;
            }

            .name-block h1 {
                font-size: 2rem;
            }

            .summary-row {
                flex-direction: column;
                gap: 1rem;
            }

            .stats-bar {
                flex-direction: row;
                justify-content: center;
                gap: 2rem;
                padding: 0.75rem 1.5rem;
            }

            .carousel-tabs {
                gap: 0.35rem;
            }

            .carousel-tab {
                padding: 0.5rem 0.8rem;
                font-size: 0.65rem;
            }

            .clients-panel {
                padding: 1.25rem;
            }

            .clients-panel .clients-section {
                margin-bottom: 1.5rem;
            }

            .clients-panel .client-grid {
                gap: 0.5rem;
            }

            .clients-panel .client-card {
                padding: 0.7rem 1rem;
            }

            .clients-panel .client-name {
                font-size: 0.75rem;
            }

            .clients-panel .client-type {
                font-size: 0.55rem;
                padding: 0.15rem 0.4rem;
            }
        }

        @media print {
            #gpu-canvas {
                display: none;
            }

            .noise-overlay {
                display: none;
            }

            body {
                background: white;
                color: #1a1a1a;
            }

            .container {
                padding: 1rem;
            }

            .project-card {
                break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <canvas id="gpu-canvas"></canvas>
    <div class="noise-overlay"></div>

    <!-- FPS Performance Badge -->
    <div class="fps-badge good" id="fps-badge" title="Real-time performance metrics">
        <span class="fps-icon"></span>
        <span class="fps-value" id="fps-value">60</span>
        <span class="fps-label">FPS</span>
    </div>

    <a href="mailto:contact.charles.grassi@gmail.com" class="contact-btn">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
        </svg>
        Contact Me
    </a>
    <div class="container">
        <header>
            <div class="name-block">
                <h1>Charles Grassi</h1>
                <p class="tagline">Freelance Graphics Programmer & Technical Artist</p>
                <div class="titles">
                    <span class="title-tag highlight">Shader Specialist</span>
                    <span class="title-tag highlight">Technical Artist</span>
                    <span class="title-tag">Graphics Engineer</span>
                    <span class="title-tag">C# Developer</span>
                </div>
            </div>
            <div class="contact-block">
                <div class="company">Zylaris Ltd · Cyprus</div>
                <a href="mailto:contact.charles.grassi@gmail.com">contact.charles.grassi@gmail.com</a>
                <a href="tel:+33646118214">(+33) 6 46 11 82 14</a>
                <a href="https://twitter.com/charles_grassi" target="_blank">@charles_grassi</a>
                <div class="languages">
                    <span class="lang">EN</span>
                    <span class="lang">FR</span>
                </div>
            </div>
        </header>

        <!-- Summary + Stats Row -->
        <div class="summary-row">
            <div class="summary">
                <p class="typewriter-text" id="typewriter-container"></p>
                <div class="typing-indicator" id="typing-indicator">Charles is typing<span class="typing-dots"><span>.</span><span>.</span><span>.</span></span></div>
            </div>
            <div class="stats-bar">
                <div class="stat-item">
                    <div class="stat-number" id="stat-years" data-target="7" data-suffix="+">0</div>
                    <div class="stat-label">Years Exp.</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="stat-studios" data-target="12" data-suffix="+">0</div>
                    <div class="stat-label">Studios</div>
                </div>
            </div>
        </div>

        <!-- Tabbed Carousel -->
        <section class="tabbed-carousel">
            <div class="carousel-tabs">
                <button class="carousel-tab active" data-panel="skills">Skills</button>
                <button class="carousel-tab" data-panel="portfolio">Portfolio</button>
                <button class="carousel-tab" data-panel="career">Career</button>
                <button class="carousel-tab" data-panel="clients">Clients</button>
                <button class="carousel-tab" data-panel="testimonials">Testimonials</button>
            </div>

            <div class="carousel-panels">
                <!-- Skills Panel - Network Graph -->
                <div class="carousel-panel skills-panel active" id="panel-skills">
                    <div class="skill-graph-container">
                        <canvas id="skill-graph-canvas"></canvas>
                        <div class="skill-tooltip" id="skill-tooltip">
                            <div class="skill-tooltip-title"></div>
                            <div class="skill-tooltip-desc"></div>
                            <div class="skill-tooltip-usage"></div>
                        </div>
                        <div class="graph-legend">
                            <div class="legend-item">
                                <span class="legend-dot primary"></span>
                                <span>Core Skills</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-dot secondary"></span>
                                <span>Secondary</span>
                            </div>
                            <div class="legend-item">
                                <span class="legend-dot tool"></span>
                                <span>Tools</span>
                            </div>
                        </div>
                        <div class="graph-hint">Drag nodes to explore</div>
                    </div>
                </div>

                <!-- Portfolio Panel - ArtStation Carousel -->
                <div class="carousel-panel portfolio-panel" id="panel-portfolio">
                    <div class="portfolio-carousel">
                        <div class="portfolio-main">
                            <button class="portfolio-nav prev" aria-label="Previous">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
                            </button>
                            <button class="portfolio-nav next" aria-label="Next">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
                            </button>

                            <div class="portfolio-slide active" data-index="0">
                                <a href="https://www.artstation.com/artwork/V216yN" target="_blank">
                                    <img src="https://cdna.artstation.com/p/assets/images/images/084/284/470/large/charles-grassi-screenshot-2025-01-11-181036-2.jpg" alt="Cave 360° Scene Composition">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Cave 360° Scene Composition</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="1">
                                <a href="https://www.artstation.com/artwork/V216JZ" target="_blank">
                                    <img src="https://cdna.artstation.com/p/assets/images/images/084/274/870/large/charles-grassi-screenshot-2024-10-08-064527.jpg" alt="Volumetric Fog | Cloud With Rain & Thunder">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Volumetric Fog | Cloud With Rain & Thunder</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="2">
                                <a href="https://www.artstation.com/artwork/WXKB2E" target="_blank">
                                    <img src="https://cdnb.artstation.com/p/assets/images/images/079/164/965/large/charles-grassi-screenshot-2024-08-15-031337.jpg" alt="Maelstrom (WIP)">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Maelstrom (WIP)</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="3">
                                <a href="https://www.artstation.com/artwork/x3AvG2" target="_blank">
                                    <img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/424/977/large/charles-grassi-thumb.jpg" alt="Cartoon Ocean Shader">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Cartoon Ocean Shader & Breakdown</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="4">
                                <a href="https://www.artstation.com/artwork/EzqE08" target="_blank">
                                    <img src="https://cdnb.artstation.com/p/assets/images/images/078/404/623/large/charles-grassi-screenshot-2024-03-06-030921.jpg" alt="Raytraced Mountain Scene">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Raytraced Mountain Scene in a Single Shader</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="5">
                                <a href="https://www.artstation.com/artwork/6LnRor" target="_blank">
                                    <img src="https://cdna.artstation.com/p/assets/images/images/078/403/874/large/charles-grassi-screenshot-2023-11-01-200540.jpg" alt="SABDA Projection Mapping">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">SABDA - Projection Mapping Immersive 360° Scenes</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="6">
                                <a href="https://www.artstation.com/artwork/6LnRor" target="_blank">
                                    <img src="https://cdnb.artstation.com/p/assets/images/images/078/403/499/large/charles-grassi-copy-of-sabda-20240118-005.jpg" alt="SABDA Projection Mapping">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">SABDA - Projection Mapping Immersive 360° Scenes</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="7">
                                <a href="https://www.artstation.com/artwork/6LnRor" target="_blank">
                                    <img src="https://cdnb.artstation.com/p/assets/images/images/078/435/209/large/charles-grassi-copy-of-sabda-20240118-010.jpg" alt="SABDA Projection Mapping">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">SABDA - Projection Mapping Immersive 360° Scenes</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="8">
                                <a href="https://www.artstation.com/artwork/zxKvQw" target="_blank">
                                    <img src="https://cdnb.artstation.com/p/assets/images/images/084/275/951/large/charles-grassi-screenshot-2023-12-25-213543.jpg" alt="Space Colonization Algorithm">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Multi-Threaded Space Colonization Algorithm</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="9">
                                <a href="https://www.artstation.com/artwork/K36Por" target="_blank">
                                    <img src="https://cdna.artstation.com/p/assets/images/images/078/403/954/large/charles-grassi-screenshot-2023-10-18-193823.jpg" alt="Alien Egg Shader">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Alien Egg Shader</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="10">
                                <a href="https://www.artstation.com/artwork/nJwNLO" target="_blank">
                                    <img src="https://cdna.artstation.com/p/assets/images/images/078/429/084/large/charles-grassi-sandbox-stylized-cloud-night.jpg" alt="Sandbox Stylized Cloud Shaders">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Sandbox Stylized Cloud & God Rays Shader</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="11">
                                <a href="https://www.artstation.com/artwork/gRgVEK" target="_blank">
                                    <img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/425/435/large/charles-grassi-thumb.jpg" alt="Oily Ocean Surface Shader">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Oily Ocean Surface Shader</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="12">
                                <a href="https://www.artstation.com/artwork/JraPGz" target="_blank">
                                    <img src="https://cdnb.artstation.com/p/assets/images/images/078/404/507/large/charles-grassi-screenshot-2023-03-27-145100.jpg" alt="Baked Volumetric Colored Fog">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Baked Volumetric Colored Fog</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="13">
                                <a href="https://www.artstation.com/artwork/V2oaP4" target="_blank">
                                    <img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/425/261/large/charles-grassi-thumb.jpg" alt="Single Draw Call Grass Shader">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Single Draw Call Grass Shader</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="14">
                                <a href="https://www.artstation.com/artwork/Ovqgby" target="_blank">
                                    <img src="https://cdna.artstation.com/p/assets/video_clips/images/078/425/098/large/charles-grassi-thumb.jpg" alt="Marching Cube Terrain">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">CPU Multi-Threaded Burst Marching Cube Terrain</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="15">
                                <a href="https://www.artstation.com/artwork/Bko5el" target="_blank">
                                    <img src="https://cdna.artstation.com/p/assets/images/images/078/519/226/large/charles-grassi-screenshot-2023-10-29-140203-2.jpg" alt="HDRP Interior Lighting">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">HDRP - Interior Lighting Scenarios</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                            <div class="portfolio-slide" data-index="16">
                                <a href="https://www.artstation.com/artwork/wrAvRL" target="_blank">
                                    <img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/425/243/large/charles-grassi-thumb.jpg" alt="Orthographic Water Surface">
                                </a>
                                <div class="portfolio-info">
                                    <div class="portfolio-title">Orthographic Water Surface</div>
                                    <div class="portfolio-link">View on ArtStation</div>
                                </div>
                            </div>
                        </div>
                        <div class="portfolio-thumbnails" id="portfolio-thumbnails">
                            <div class="portfolio-thumb active" data-index="0"><img src="https://cdna.artstation.com/p/assets/images/images/084/284/470/small_square/charles-grassi-screenshot-2025-01-11-181036-2.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="1"><img src="https://cdna.artstation.com/p/assets/images/images/084/274/870/small_square/charles-grassi-screenshot-2024-10-08-064527.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="2"><img src="https://cdnb.artstation.com/p/assets/images/images/079/164/965/small_square/charles-grassi-screenshot-2024-08-15-031337.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="3"><img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/424/977/small_square/charles-grassi-thumb.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="4"><img src="https://cdnb.artstation.com/p/assets/images/images/078/404/623/small_square/charles-grassi-screenshot-2024-03-06-030921.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="5"><img src="https://cdna.artstation.com/p/assets/images/images/078/403/874/small_square/charles-grassi-screenshot-2023-11-01-200540.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="6"><img src="https://cdnb.artstation.com/p/assets/images/images/078/403/499/small_square/charles-grassi-copy-of-sabda-20240118-005.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="7"><img src="https://cdnb.artstation.com/p/assets/images/images/078/435/209/small_square/charles-grassi-copy-of-sabda-20240118-010.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="8"><img src="https://cdnb.artstation.com/p/assets/images/images/084/275/951/small_square/charles-grassi-screenshot-2023-12-25-213543.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="9"><img src="https://cdna.artstation.com/p/assets/images/images/078/403/954/small_square/charles-grassi-screenshot-2023-10-18-193823.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="10"><img src="https://cdna.artstation.com/p/assets/images/images/078/429/084/small_square/charles-grassi-sandbox-stylized-cloud-night.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="11"><img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/425/435/small_square/charles-grassi-thumb.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="12"><img src="https://cdnb.artstation.com/p/assets/images/images/078/404/507/small_square/charles-grassi-screenshot-2023-03-27-145100.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="13"><img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/425/261/small_square/charles-grassi-thumb.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="14"><img src="https://cdna.artstation.com/p/assets/video_clips/images/078/425/098/small_square/charles-grassi-thumb.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="15"><img src="https://cdna.artstation.com/p/assets/images/images/078/519/226/small_square/charles-grassi-screenshot-2023-10-29-140203-2.jpg" alt=""></div>
                            <div class="portfolio-thumb" data-index="16"><img src="https://cdnb.artstation.com/p/assets/video_clips/images/078/425/243/small_square/charles-grassi-thumb.jpg" alt=""></div>
                        </div>
                        <div class="portfolio-counter"><span id="portfolio-current">1</span> / <span id="portfolio-total">17</span></div>
                    </div>
                </div>

                <!-- Career Panel - Timeline -->
                <div class="carousel-panel career-panel" id="panel-career">
                    <div class="project-list-wrapper" id="project-list-wrapper">
                        <div class="project-list" id="project-list">
                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Technical Artist & Graphics Programmer</div>
                                        <div class="project-client">Nexus Studios</div>
                                    </div>
                                    <div class="project-year">2025</div>
                                </div>
                                <div class="project-desc">
                                    Built a real-time global illumination system using SDF representations of scanned VR environments.
                                    Implemented GPU compute pipelines for efficient light transport calculations optimized for VR hardware constraints.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Compute Shaders</span>
                                    <span class="tech-tag">SDF</span>
                                    <span class="tech-tag">VR</span>
                                    <span class="tech-tag">Global Illumination</span>
                                </div>
                            </article>

                            <article class="project-card leadership-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Chief Technology Officer</div>
                                        <div class="project-client">SABDA</div>
                                    </div>
                                    <div class="project-year">2023–2024</div>
                                </div>
                                <div class="project-desc">
                                    Led technical direction for a large-scale 16K immersive installation. Developed real-time 3D content,
                                    managed spatial audio systems, server infrastructure, and projection mapping pipelines.
                                    Built and led a multicultural engineering team.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Projection Mapping</span>
                                    <span class="tech-tag">Spatial Audio</span>
                                    <span class="tech-tag">Real-time 3D</span>
                                    <span class="tech-tag">Team Leadership</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Lead Graphics Programmer</div>
                                        <div class="project-client">Little Red Dog Games</div>
                                    </div>
                                    <div class="project-year">2023</div>
                                </div>
                                <div class="project-desc">
                                    Directed graphics team to develop high-performance VFX using compute shaders and Burst-compiled code.
                                    Achieved significant CPU performance optimizations while maintaining visual fidelity.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Compute Shaders</span>
                                    <span class="tech-tag">Burst</span>
                                    <span class="tech-tag">VFX</span>
                                    <span class="tech-tag">Team Lead</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Senior Graphics Programmer</div>
                                        <div class="project-client">22cans</div>
                                    </div>
                                    <div class="project-year">2023</div>
                                </div>
                                <div class="project-desc">
                                    Created versatile shader library targeting mobile and desktop simultaneously. Developed performant
                                    grass rendering and volumetric lighting effects that maintained visual quality across hardware tiers.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">HLSL</span>
                                    <span class="tech-tag">Mobile</span>
                                    <span class="tech-tag">Volumetrics</span>
                                    <span class="tech-tag">Grass</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Shader Expert</div>
                                        <div class="project-client">GN3RA</div>
                                    </div>
                                    <div class="project-year">2023</div>
                                </div>
                                <div class="project-desc">
                                    Developed customizable HDRP cloth shaders for fashion and character rendering.
                                    Optimized visual effects and lighting systems for high-fidelity real-time applications.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">HDRP</span>
                                    <span class="tech-tag">Cloth Simulation</span>
                                    <span class="tech-tag">VFX</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Graphics Programmer</div>
                                        <div class="project-client">Scapin' · The Sandbox</div>
                                    </div>
                                    <div class="project-year">2021–2022</div>
                                </div>
                                <div class="project-desc">
                                    Engineered custom lighting systems for web3 social applications. Built stylized cloud shaders
                                    and optimized mobile blur effects while delivering premium visual aesthetics.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Lighting</span>
                                    <span class="tech-tag">Mobile Optimization</span>
                                    <span class="tech-tag">Web3</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Shader Expert</div>
                                        <div class="project-client">DREST</div>
                                    </div>
                                    <div class="project-year">2022</div>
                                </div>
                                <div class="project-desc">
                                    Delivered specialized shader solutions for fashion tech applications.
                                    Focused on performance optimization and high-quality material rendering.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Fashion Tech</span>
                                    <span class="tech-tag">Materials</span>
                                    <span class="tech-tag">Optimization</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Unity Developer & Technical Artist</div>
                                        <div class="project-client">Lunchbox Entertainment</div>
                                    </div>
                                    <div class="project-year">2021–2022</div>
                                </div>
                                <div class="project-desc">
                                    Created terrain, clouds, water, caustics, and bubble VFX shaders for game environments.
                                    Combined technical programming with artistic direction for immersive visual experiences.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">Water Shaders</span>
                                    <span class="tech-tag">VFX</span>
                                    <span class="tech-tag">Environment Art</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Graphics Engineer</div>
                                        <div class="project-client">H3 Space</div>
                                    </div>
                                    <div class="project-year">2021</div>
                                </div>
                                <div class="project-desc">
                                    Developed graphics solutions for AR/VR applications. Specialized in performance optimization
                                    and visual effects for immersive spatial computing experiences.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">AR/VR</span>
                                    <span class="tech-tag">Optimization</span>
                                    <span class="tech-tag">3D Math</span>
                                </div>
                            </article>

                            <article class="project-card">
                                <div class="project-header">
                                    <div>
                                        <div class="project-title">Unity Developer & Graphics Programmer</div>
                                        <div class="project-client">Ubisoft</div>
                                    </div>
                                    <div class="project-year">2020–2021</div>
                                </div>
                                <div class="project-desc">
                                    Delivered graphics programming expertise for AAA game development.
                                    Specialized in performance analysis, VFX, and cross-platform rendering optimization.
                                </div>
                                <div class="project-tags">
                                    <span class="tech-tag">AAA</span>
                                    <span class="tech-tag">VFX</span>
                                    <span class="tech-tag">Performance</span>
                                </div>
                            </article>
                        </div>
                        <p class="scroll-hint">Scroll to see more</p>
                    </div>
                </div>

                <!-- Clients Panel -->
                <div class="carousel-panel clients-panel" id="panel-clients">
                    <div class="clients-section">
                        <div class="section-label">Featured Partners</div>
                        <div class="client-grid">
                            <a href="https://nexusstudios.com/" target="_blank" class="client-card major">
                                <span class="client-name">Nexus Studios</span>
                                <span class="client-type">VR / Immersive</span>
                            </a>
                            <a href="https://www.ubisoft.com/" target="_blank" class="client-card major">
                                <span class="client-name">Ubisoft</span>
                                <span class="client-type">AAA Games</span>
                            </a>
                            <a href="https://www.22cans.com/" target="_blank" class="client-card major">
                                <span class="client-name">22cans</span>
                                <span class="client-type">Game Studio</span>
                            </a>
                        </div>
                    </div>
                    <div class="clients-section">
                        <div class="section-label other">Collaborations</div>
                        <div class="client-grid">
                            <a href="https://www.sandbox.game/" target="_blank" class="client-card">
                                <span class="client-name">The Sandbox</span>
                                <span class="client-type">Web3 Gaming</span>
                            </a>
                            <a href="https://www.drest.com/" target="_blank" class="client-card">
                                <span class="client-name">DREST</span>
                                <span class="client-type">Fashion Tech</span>
                            </a>
                            <a href="https://www.linkedin.com/company/h3investments/posts/" target="_blank" class="client-card">
                                <span class="client-name">H3 Space</span>
                                <span class="client-type">AR / VR</span>
                            </a>
                            <a href="https://store.steampowered.com/developer/lrdg" target="_blank" class="client-card">
                                <span class="client-name">Little Red Dog</span>
                                <span class="client-type">Game Studio</span>
                            </a>
                            <a href="https://scapin.io/" target="_blank" class="client-card">
                                <span class="client-name">Scapin'</span>
                                <span class="client-type">Social App</span>
                            </a>
                            <a href="https://sabda.es/" target="_blank" class="client-card">
                                <span class="client-name">SABDA</span>
                                <span class="client-type">Immersive Art</span>
                            </a>
                            <a href="https://www.genera.so/" target="_blank" class="client-card">
                                <span class="client-name">GN3RA</span>
                                <span class="client-type">Digital Fashion</span>
                            </a>
                            <a href="https://lunchboxentertainment.com/" target="_blank" class="client-card">
                                <span class="client-name">Lunchbox Ent.</span>
                                <span class="client-type">Game Studio</span>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Testimonials Panel -->
                <div class="carousel-panel testimonials-panel" id="panel-testimonials">
                    <div class="testimonial-card">
                        <p class="testimonial-quote">Charles delivered exceptional work on our VR project. His deep understanding of GPU optimization and real-time rendering made our global illumination system possible within our hardware constraints.</p>
                        <div class="testimonial-author">
                            <div class="testimonial-avatar">NS</div>
                            <div class="testimonial-info">
                                <span class="testimonial-name">Nexus Studios</span>
                                <span class="testimonial-role">VR Production Team</span>
                            </div>
                        </div>
                    </div>
                    <div class="testimonial-card">
                        <p class="testimonial-quote">Working with Charles on our 16K immersive installation was a game-changer. His technical leadership and ability to solve complex projection mapping challenges exceeded our expectations.</p>
                        <div class="testimonial-author">
                            <div class="testimonial-avatar">SA</div>
                            <div class="testimonial-info">
                                <span class="testimonial-name">SABDA</span>
                                <span class="testimonial-role">Creative Direction</span>
                            </div>
                        </div>
                    </div>
                    <div class="testimonial-card">
                        <p class="testimonial-quote">Charles's shader expertise helped us achieve console-quality graphics on mobile devices. His optimization work significantly improved our game's performance without sacrificing visual fidelity.</p>
                        <div class="testimonial-author">
                            <div class="testimonial-avatar">22</div>
                            <div class="testimonial-info">
                                <span class="testimonial-name">22cans</span>
                                <span class="testimonial-role">Development Team</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <footer>
            <div class="footer-links">
                <a href="mailto:contact.charles.grassi@gmail.com">Email</a>
                <a href="https://twitter.com/charles_grassi">Twitter</a>
                <a href="https://linkedin.com/in/charles-grassi">LinkedIn</a>
            </div>
            <p class="footer-note">Available for consulting engagements · Remote worldwide</p>
        </footer>
    </div>

    <script>
        // Subtle Aurora Background - Charles Grassi CV
        (function () {
            const canvas = document.getElementById('gpu-canvas');
            const renderer = new THREE.WebGLRenderer({
                canvas,
                antialias: false,
                alpha: true
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.setSize(window.innerWidth, window.innerHeight);

            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            // Mouse tracking (subtle)
            const mouse = { x: 0.5, y: 0.5, targetX: 0.5, targetY: 0.5 };
            document.addEventListener('mousemove', (e) => {
                mouse.targetX = e.clientX / window.innerWidth;
                mouse.targetY = 1.0 - e.clientY / window.innerHeight;
            });

            // Fullscreen shader
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float uTime;
                uniform vec2 uMouse;
                uniform vec2 uResolution;

                varying vec2 vUv;

                // Simplex noise
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

                float snoise(vec2 v) {
                    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                                       -0.577350269189626, 0.024390243902439);
                    vec2 i  = floor(v + dot(v, C.yy));
                    vec2 x0 = v - i + dot(i, C.xx);
                    vec2 i1;
                    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                    vec4 x12 = x0.xyxy + C.xxzz;
                    x12.xy -= i1;
                    i = mod289(i);
                    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                        + i.x + vec3(0.0, i1.x, 1.0));
                    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                        dot(x12.zw,x12.zw)), 0.0);
                    m = m*m;
                    m = m*m;
                    vec3 x = 2.0 * fract(p * C.www) - 1.0;
                    vec3 h = abs(x) - 0.5;
                    vec3 ox = floor(x + 0.5);
                    vec3 a0 = x - ox;
                    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
                    vec3 g;
                    g.x = a0.x * x0.x + h.x * x0.y;
                    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                    return 130.0 * dot(m, g);
                }

                void main() {
                    vec2 uv = vUv;

                    // Slow flowing noise
                    float noise1 = snoise(uv * 1.5 + uTime * 0.05);
                    float noise2 = snoise(uv * 2.5 - uTime * 0.03 + 100.0);
                    float noise3 = snoise(uv * 0.8 + uTime * 0.02 + vec2(noise1 * 0.2));

                    float combinedNoise = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2;

                    // Colors
                    vec3 gold = vec3(0.91, 0.73, 0.14);
                    vec3 teal = vec3(0.18, 0.83, 0.75);
                    vec3 dark = vec3(0.04, 0.06, 0.08);

                    // Subtle color bands
                    float band1 = smoothstep(-0.3, 0.3, combinedNoise);
                    float band2 = smoothstep(0.0, 0.6, combinedNoise);

                    vec3 color = mix(dark, gold * 0.15, band1 * 0.4);
                    color = mix(color, teal * 0.12, band2 * 0.3);

                    // Very subtle mouse glow
                    float mouseDist = length(uv - uMouse);
                    float mouseGlow = exp(-mouseDist * 3.0) * 0.08;
                    color += teal * mouseGlow;

                    // Vignette
                    float vignette = 1.0 - length(uv - 0.5) * 0.5;
                    color *= vignette;

                    // Keep it very subtle
                    float alpha = 0.6;

                    gl_FragColor = vec4(color, alpha);
                }
            `;

            const geometry = new THREE.PlaneGeometry(2, 2);
            const material = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uMouse: { value: new THREE.Vector2(0.5, 0.5) },
                    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                },
                transparent: true,
                depthWrite: false
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Sparse floating particles
            const particleVertexShader = `
                uniform float uTime;
                uniform float uPixelRatio;
                attribute float aScale;
                attribute float aSpeed;
                varying float vAlpha;

                void main() {
                    vec3 pos = position;

                    // Gentle drift
                    pos.x += sin(uTime * aSpeed * 0.5 + position.y * 2.0) * 0.02;
                    pos.y += mod(uTime * aSpeed * 0.1, 2.0) - 1.0;
                    pos.y = mod(pos.y + 1.0, 2.0) - 1.0;

                    gl_Position = vec4(pos, 1.0);
                    gl_PointSize = aScale * uPixelRatio * 3.0;

                    // Fade at edges
                    vAlpha = smoothstep(1.0, 0.7, abs(pos.y)) * 0.4;
                }
            `;

            const particleFragmentShader = `
                varying float vAlpha;

                void main() {
                    float dist = length(gl_PointCoord - 0.5);
                    float alpha = smoothstep(0.5, 0.0, dist) * vAlpha;
                    vec3 color = mix(vec3(0.91, 0.73, 0.14), vec3(0.18, 0.83, 0.75), 0.5);
                    gl_FragColor = vec4(color, alpha);
                }
            `;

            const PARTICLE_COUNT = 60;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const scales = new Float32Array(PARTICLE_COUNT);
            const speeds = new Float32Array(PARTICLE_COUNT);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 2;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
                positions[i * 3 + 2] = 0;
                scales[i] = Math.random() * 1.5 + 0.5;
                speeds[i] = Math.random() * 0.5 + 0.2;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
            particleGeometry.setAttribute('aSpeed', new THREE.BufferAttribute(speeds, 1));

            const particleMaterial = new THREE.ShaderMaterial({
                vertexShader: particleVertexShader,
                fragmentShader: particleFragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }
                },
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // Animation
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);

                time += 0.016;

                mouse.x += (mouse.targetX - mouse.x) * 0.02;
                mouse.y += (mouse.targetY - mouse.y) * 0.02;

                material.uniforms.uTime.value = time;
                material.uniforms.uMouse.value.set(mouse.x, mouse.y);

                particleMaterial.uniforms.uTime.value = time;

                renderer.render(scene, camera);
            }

            animate();

            window.addEventListener('resize', () => {
                renderer.setSize(window.innerWidth, window.innerHeight);
                material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
            });

            document.addEventListener('visibilitychange', () => {
                // Continues running but at low cost anyway
            });
        })();

        // Skill Network Graph
        (function() {
            const canvas = document.getElementById('skill-graph-canvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const container = canvas.parentElement;
            let time = 0;

            // Colors matching the site theme
            const colors = {
                gold: '#e8b923',
                goldDim: '#c49a1a',
                teal: '#2dd4bf',
                tealDim: '#1a9a87',
                textPrimary: '#e8eaed',
                textMuted: '#6b7280',
                border: '#1f2937',
                bgCard: '#151d26'
            };

            // Skill nodes with categories and descriptions
            // baseSize is the reference size at 400px canvas dimension
            const skills = [
                // Core skills - first 3 are light sources with unique colors
                { id: 'unity', label: 'Unity', category: 'primary', baseSize: 34, isLight: true, lightColor: '#ffaa33',
                  desc: 'Primary game engine', usage: 'Daily since 2017 - shipped 12+ titles across mobile, PC, and VR platforms' },
                { id: 'csharp', label: 'C#', category: 'primary', baseSize: 33, isLight: true, lightColor: '#9b4dca',
                  desc: 'Main programming language', usage: '7+ years - gameplay systems, editor tools, and performance-critical code' },
                { id: 'hlsl', label: 'HLSL/GLSL', category: 'primary', baseSize: 31, isLight: true, lightColor: '#33ddff',
                  desc: 'Shader programming', usage: 'Custom rendering pipelines, VFX, post-processing, and compute shaders' },
                { id: 'directx', label: 'DirectX', category: 'secondary', baseSize: 15,
                  desc: 'Graphics API', usage: 'DX11/DX12 for Windows and Xbox development' },
                { id: 'arvr', label: 'AR/VR', category: 'secondary', baseSize: 13,
                  desc: 'Immersive experiences', usage: 'Meta Quest, HoloLens, and mobile AR projects' },
                { id: 'urp', label: 'URP/HDRP', category: 'secondary', baseSize: 13,
                  desc: 'Unity render pipelines', usage: 'Custom render features, shader graphs, and pipeline extensions' },

                // Secondary skills (teal)
                { id: 'opengl', label: 'OpenGL', category: 'secondary', baseSize: 14,
                  desc: 'Cross-platform graphics', usage: 'Mobile and Linux rendering targets' },
                { id: 'unreal', label: 'Unreal', category: 'secondary', baseSize: 16,
                  desc: 'Secondary engine', usage: 'Blueprint systems and material editor for specific projects' },
                { id: 'vulkan', label: 'Vulkan', category: 'secondary', baseSize: 15,
                  desc: 'Low-level graphics API', usage: 'Performance optimization on Android and Linux' },
                { id: 'python', label: 'Python', category: 'secondary', baseSize: 14,
                  desc: 'Scripting & tools', usage: 'Build automation, asset pipelines, and data processing' },
                { id: 'cpp', label: 'C++', category: 'secondary', baseSize: 8,
                  desc: 'Systems programming', usage: 'Native plugins, engine modifications, and Unreal development' },
                { id: 'wpf', label: 'WPF', category: 'secondary', baseSize: 12,
                  desc: 'Desktop UI framework', usage: 'Internal tools and editors for game development' },
                { id: 'compute', label: 'Compute', category: 'secondary', baseSize: 17,
                  desc: 'GPU compute shaders', usage: 'Particle simulations, procedural generation, and physics' },
                { id: 'vfx', label: 'VFX Graph', category: 'secondary', baseSize: 12,
                  desc: 'Unity visual effects', usage: 'GPU-driven particle systems and real-time simulations' },
                { id: 'niagara', label: 'Niagara', category: 'secondary', baseSize: 17,
                  desc: 'Unreal VFX system', usage: 'Complex particle effects for Unreal projects' },
                { id: 'threejs', label: 'Three.js', category: 'secondary', baseSize: 8,
                  desc: 'WebGL framework', usage: 'Interactive 3D web experiences and visualizations' },
                { id: 'webgl', label: 'WebGL', category: 'secondary', baseSize: 6,
                  desc: 'Browser graphics', usage: 'Custom shaders and real-time web graphics' },

                // Tools (muted)
                { id: 'renderdoc', label: 'RenderDoc', category: 'tool', baseSize: 16,
                  desc: 'Graphics debugger', usage: 'Frame analysis and shader debugging' },
                { id: 'nsight', label: 'NSight', category: 'tool', baseSize: 14,
                  desc: 'NVIDIA profiler', usage: 'GPU performance analysis and optimization' },
                { id: 'pix', label: 'PIX', category: 'tool', baseSize: 6,
                  desc: 'DirectX debugger', usage: 'Windows and Xbox graphics debugging' }
            ];

            // Reference dimension for scaling (sizes are designed for this)
            const BASE_DIMENSION = 400;
            let sizeScale = 1;

            // Connections between skills
            const connections = [
                ['unity', 'csharp'], ['unity', 'hlsl'], ['unity', 'urp'], ['unity', 'arvr'],
                ['unity', 'vfx'], ['unity', 'compute'],
                ['csharp', 'wpf'], ['csharp', 'compute'],
                ['hlsl', 'directx'], ['hlsl', 'opengl'], ['hlsl', 'vulkan'], ['hlsl', 'urp'],
                ['directx', 'renderdoc'], ['directx', 'pix'], ['directx', 'nsight'],
                ['opengl', 'vulkan'], ['opengl', 'webgl'],
                ['unreal', 'cpp'], ['unreal', 'niagara'], ['unreal', 'hlsl'],
                ['cpp', 'directx'], ['cpp', 'vulkan'],
                ['compute', 'vfx'], ['compute', 'hlsl'],
                ['threejs', 'webgl'], ['threejs', 'hlsl'],
                ['arvr', 'urp'], ['arvr', 'compute'],
                ['vfx', 'niagara'],
                ['python', 'unity']
            ];

            // Initialize node positions with unique animation properties
            let nodes = skills.map((skill, i) => {
                const angle = (i / skills.length) * Math.PI * 2;
                const radius = 150 + Math.random() * 50;
                return {
                    ...skill,
                    size: skill.baseSize, // Will be updated on resize
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    baseX: 0,
                    baseY: 0,
                    // Animation parameters for slow organic movement
                    floatSpeed: 0.03 + Math.random() * 0.03,
                    floatRadius: 2 + Math.random() * 3,
                    floatPhase: Math.random() * Math.PI * 2,
                    floatSpeed2: 0.02 + Math.random() * 0.02, // Secondary wobble
                    floatRadius2: 1 + Math.random() * 2,
                    pulseSpeed: 0.05 + Math.random() * 0.1,
                    pulsePhase: Math.random() * Math.PI * 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.001,
                    // Orbit behavior for non-light nodes
                    orbitAngle: Math.random() * Math.PI * 2,
                    orbitSpeed: 0.02 + Math.random() * 0.02,
                    orbitRadius: 2 + Math.random() * 4,
                    // Glow animation state
                    glowIntensity: 0,
                    targetGlowIntensity: 0,
                    glowDelay: 0,
                    // Shrink animation for non-connected nodes
                    shrinkProgress: 1, // 1 = full size, 0 = invisible
                    targetShrink: 1
                };
            });

            let width, height, centerX, centerY;
            let isDragging = false;
            let dragNode = null;
            let hoveredNode = null;
            let mouseX = 0, mouseY = 0;
            let settled = false;
            let settleTimer = 0;
            let startupPhase = true; // Delays showcase until nodes appear
            let globalFadeIn = 0; // Simple 0-1 fade in for all nodes

            // Tooltip element and connector line
            const tooltip = document.getElementById('skill-tooltip');
            const tooltipTitle = tooltip.querySelector('.skill-tooltip-title');
            const tooltipDesc = tooltip.querySelector('.skill-tooltip-desc');
            const tooltipUsage = tooltip.querySelector('.skill-tooltip-usage');

            let tooltipTarget = null; // Current node the tooltip is attached to
            let tooltipPos = { x: 0, y: 0 }; // Position for tooltip
            let tooltipConnectPoint = { x: 0, y: 0 }; // Connection point on tooltip edge
            let lineAnimProgress = 0; // Animation progress 0-1
            let lineAnimStartTime = 0;
            const lineAnimDuration = 300; // ms for line to draw
            let tooltipSide = 'right'; // 'left' or 'right'

            // Random skill showcase (shows tooltip without hover effects)
            let showcaseNode = null;
            let showcaseActive = false;
            let lastShowcaseTime = 0;
            const showcaseInterval = 2000; // Time between showcases
            const showcaseDuration = 4000; // How long to show each showcase

            function startRandomShowcase() {
                // Don't start if user is hovering, dragging, or during startup
                if (hoveredNode || isDragging || startupPhase) return;

                // Pick a random node that isn't the current showcase
                const availableNodes = nodes.filter(n => n !== showcaseNode);
                if (availableNodes.length === 0) return;

                showcaseNode = availableNodes[Math.floor(Math.random() * availableNodes.length)];
                showcaseActive = true;

                // Generate tooltip position and show it
                generateTooltipPosition(showcaseNode);
                tooltipTarget = showcaseNode;
                tooltipTitle.textContent = showcaseNode.label;
                tooltipDesc.textContent = showcaseNode.desc || '';
                tooltipUsage.textContent = showcaseNode.usage || '';
                tooltip.className = 'skill-tooltip ' + showcaseNode.category;
                tooltip.style.left = tooltipPos.x + 'px';
                tooltip.style.top = tooltipPos.y + 'px';

                lastShowcaseTime = performance.now();
            }

            function updateShowcase() {
                const now = performance.now();

                // Don't run showcase during startup phase
                if (startupPhase) {
                    lastShowcaseTime = now; // Keep resetting timer
                    return;
                }

                // If user hovers, cancel the showcase
                if (hoveredNode || isDragging) {
                    if (showcaseActive && tooltipTarget === showcaseNode) {
                        // User took over - let the hover handle it
                        showcaseActive = false;
                        showcaseNode = null;
                    }
                    lastShowcaseTime = now; // Reset timer
                    return;
                }

                // If showcase is active, check if it should end
                if (showcaseActive) {
                    if (now - lastShowcaseTime > showcaseDuration) {
                        // End showcase
                        showcaseActive = false;
                        tooltip.classList.remove('visible');
                        tooltipTarget = null;
                        lineAnimProgress = 0;
                        lastShowcaseTime = now;
                    }
                    return;
                }

                // Check if it's time for a new showcase
                if (now - lastShowcaseTime > showcaseInterval) {
                    startRandomShowcase();
                }
            }

            // Offset from node to tooltip (set once when tooltip appears)
            let tooltipOffset = { x: 0, y: 0 };
            const tooltipWidth = 260;
            const tooltipHeight = 120;

            function generateTooltipPosition(node) {
                const margin = 20;

                // Randomly choose left or right side
                tooltipSide = Math.random() > 0.5 ? 'right' : 'left';

                let tx, ty;

                if (tooltipSide === 'right') {
                    // Position on right side of canvas
                    tx = width - tooltipWidth - margin;
                } else {
                    // Position on left side of canvas
                    tx = margin;
                }

                // Random vertical position, but try to align somewhat with node
                const minY = margin;
                const maxY = height - tooltipHeight - margin;
                ty = node.y - tooltipHeight / 2 + (Math.random() - 0.5) * 100;
                ty = Math.max(minY, Math.min(maxY, ty));

                tooltipPos = { x: tx, y: ty };

                // Store offset from node position to tooltip position
                tooltipOffset = { x: tx - node.x, y: ty - node.y };

                // Connection point is on the edge facing the node
                if (tooltipSide === 'right') {
                    tooltipConnectPoint = {
                        x: tx,
                        y: ty + tooltipHeight / 2
                    };
                } else {
                    tooltipConnectPoint = {
                        x: tx + tooltipWidth,
                        y: ty + tooltipHeight / 2
                    };
                }

                // Start line animation
                lineAnimProgress = 0;
                lineAnimStartTime = performance.now();
            }

            function updateTooltipPositionForDrag(node) {
                // Update tooltip position maintaining the offset from the node
                const margin = 20;
                let tx = node.x + tooltipOffset.x;
                let ty = node.y + tooltipOffset.y;

                // Clamp to canvas bounds
                tx = Math.max(margin, Math.min(width - tooltipWidth - margin, tx));
                ty = Math.max(margin, Math.min(height - tooltipHeight - margin, ty));

                tooltipPos = { x: tx, y: ty };

                // Update connection point
                if (tooltipSide === 'right') {
                    tooltipConnectPoint = {
                        x: tx,
                        y: ty + tooltipHeight / 2
                    };
                } else {
                    tooltipConnectPoint = {
                        x: tx + tooltipWidth,
                        y: ty + tooltipHeight / 2
                    };
                }

                tooltip.style.left = tooltipPos.x + 'px';
                tooltip.style.top = tooltipPos.y + 'px';
            }

            function updateTooltip(node, forceKeep = false) {
                if (node) {
                    // Only generate new position if hovering a new node (and not dragging)
                    if (tooltipTarget !== node && !isDragging) {
                        tooltipTarget = node;
                        generateTooltipPosition(node);
                        // Hide tooltip initially - will show when line finishes
                        tooltip.classList.remove('visible');
                    }

                    tooltipTitle.textContent = node.label;
                    tooltipDesc.textContent = node.desc || '';
                    tooltipUsage.textContent = node.usage || '';

                    // Set category class for color (visible class added when line completes)
                    tooltip.className = 'skill-tooltip ' + node.category + (lineAnimProgress >= 1 ? ' visible' : '');

                    tooltip.style.left = tooltipPos.x + 'px';
                    tooltip.style.top = tooltipPos.y + 'px';
                } else if (!forceKeep) {
                    tooltip.classList.remove('visible');
                    tooltipTarget = null;
                    lineAnimProgress = 0;
                }
            }

            function drawTooltipConnector() {
                if (!tooltipTarget) return;

                // Update animation progress
                const elapsed = performance.now() - lineAnimStartTime;
                lineAnimProgress = Math.min(1, elapsed / lineAnimDuration);

                // Show tooltip when line completes
                if (lineAnimProgress >= 1 && !tooltip.classList.contains('visible')) {
                    tooltip.classList.add('visible');
                }

                const node = tooltipTarget;
                const nodeX = node.x;
                const nodeY = node.y;
                const connX = tooltipConnectPoint.x;
                const connY = tooltipConnectPoint.y;

                // Get line color based on category
                let lineColor;
                if (node.category === 'primary') {
                    lineColor = colors.gold;
                } else if (node.category === 'secondary') {
                    lineColor = colors.teal;
                } else {
                    lineColor = colors.textMuted;
                }

                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 1.5;
                ctx.globalAlpha = 0.8;

                // Calculate the corner point for L-shape
                // First go vertical from node, then horizontal to tooltip
                const cornerX = nodeX;
                const cornerY = connY;

                // Calculate total line length for animation
                const verticalDist = Math.abs(cornerY - nodeY);
                const horizontalDist = Math.abs(connX - cornerX);
                const totalDist = verticalDist + horizontalDist;

                // How much of the line to draw based on animation progress
                const drawDist = totalDist * lineAnimProgress;

                ctx.beginPath();
                ctx.moveTo(nodeX, nodeY);

                if (drawDist <= verticalDist) {
                    // Still drawing vertical portion
                    const progress = drawDist / verticalDist;
                    const currentY = nodeY + (cornerY - nodeY) * progress;
                    ctx.lineTo(nodeX, currentY);
                } else {
                    // Vertical complete, drawing horizontal
                    ctx.lineTo(cornerX, cornerY);
                    const remainingDist = drawDist - verticalDist;
                    const horizontalProgress = remainingDist / horizontalDist;
                    const currentX = cornerX + (connX - cornerX) * horizontalProgress;
                    ctx.lineTo(currentX, cornerY);
                }

                ctx.stroke();
                ctx.globalAlpha = 1;

                // Draw small circle at node connection point
                ctx.beginPath();
                ctx.arc(nodeX, nodeY, 3, 0, Math.PI * 2);
                ctx.fillStyle = lineColor;
                ctx.fill();
            }

            function resize() {
                const rect = container.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                width = rect.width;
                height = rect.height;
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                centerX = width / 2;
                centerY = height / 2;
                settled = false;
                settleTimer = 0;

                // Calculate size scale based on canvas dimensions
                // Use the smaller dimension for scaling, with min/max limits
                const minDim = Math.min(width, height);
                sizeScale = Math.max(0.5, Math.min(1.2, minDim / BASE_DIMENSION));

                // Initialize positions spread out
                nodes.forEach((node, i) => {
                    const angle = (i / nodes.length) * Math.PI * 2 + Math.PI / 4;
                    const radius = Math.min(width, height) * 0.35;
                    node.x = centerX + Math.cos(angle) * radius * (0.6 + Math.random() * 0.4);
                    node.y = centerY + Math.sin(angle) * radius * (0.6 + Math.random() * 0.4);
                    node.baseX = node.x;
                    node.baseY = node.y;
                    node.vx = 0;
                    node.vy = 0;
                    // Update node size based on scale
                    node.size = node.baseSize * sizeScale;
                });

                // Resize WebGL canvas
                resizeSphereGL();
            }

            function getNodeAt(x, y) {
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const node = nodes[i];
                    const dx = x - node.x;
                    const dy = y - node.y;
                    const hitRadius = node.size + 5;
                    if (dx * dx + dy * dy < hitRadius * hitRadius) {
                        return node;
                    }
                }
                return null;
            }

            function getConnectedNodes(node) {
                const connected = new Set();
                connections.forEach(([a, b]) => {
                    if (a === node.id) connected.add(b);
                    if (b === node.id) connected.add(a);
                });
                return connected;
            }

            // Physics simulation - stronger forces when dragging
            function simulate() {
                // Simple global fade in - delay 1.5s then fade over 2s
                if (globalFadeIn < 1) {
                    if (time > 1.5) {
                        globalFadeIn = Math.min(1, (time - 1.5) / 2);
                    }
                }

                // End startup phase when fully visible
                if (globalFadeIn >= 1) {
                    startupPhase = false;
                }

                // Scale physics parameters based on canvas size
                const scaleSquared = sizeScale * sizeScale;

                // Normal physics - runs even during startup (nodes are just invisible)
                const repulsion = (dragNode ? 5000 : 3000) * scaleSquared;
                const attraction = dragNode ? 0.005 : 0.003;
                const damping = 0.95;
                const centerPull = 0.002;

                let totalMovement = 0;

                nodes.forEach((nodeA, idxA) => {
                    if (nodeA === dragNode) return;

                    let fx = 0, fy = 0;

                    // Strong repulsion from ALL other nodes (not just nearby)
                    nodes.forEach((nodeB, idxB) => {
                        if (nodeA === nodeB) return;
                        const dx = nodeA.x - nodeB.x;
                        const dy = nodeA.y - nodeB.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const minDist = (nodeA.size + nodeB.size + 80 * sizeScale);

                        // Always apply some repulsion, stronger when close
                        const force = repulsion / (dist * dist + 100);
                        fx += (dx / dist) * force;
                        fy += (dy / dist) * force;
                    });

                    // Gentle attraction along connections (longer ideal distance)
                    connections.forEach(([a, b]) => {
                        let other = null;
                        if (a === nodeA.id) other = nodes.find(n => n.id === b);
                        if (b === nodeA.id) other = nodes.find(n => n.id === a);
                        if (other) {
                            const dx = other.x - nodeA.x;
                            const dy = other.y - nodeA.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const idealDist = 180 * sizeScale; // Longer connections
                            if (dist > idealDist) {
                                const strength = (dist - idealDist) * attraction;
                                fx += (dx / dist) * strength;
                                fy += (dy / dist) * strength;
                            }
                        }
                    });

                    // Light sources orbit very slowly around center
                    if (nodeA.isLight) {
                        const orbitRadius = 80 * sizeScale;
                        const orbitSpeed = 0.06 + idxA * 0.01;
                        const orbitPhase = idxA * (Math.PI * 2 / 3);
                        const targetX = centerX + Math.cos(time * orbitSpeed + orbitPhase) * orbitRadius;
                        const targetY = centerY + Math.sin(time * orbitSpeed + orbitPhase) * orbitRadius;
                        fx += (targetX - nodeA.x) * 0.02;
                        fy += (targetY - nodeA.y) * 0.02;
                    }

                    // Pull toward center (weaker for more spread)
                    fx += (centerX - nodeA.x) * centerPull;
                    fy += (centerY - nodeA.y) * centerPull;

                    // Subtle mouse attraction/interaction
                    const mouseDx = mouseX - nodeA.x;
                    const mouseDy = mouseY - nodeA.y;
                    const mouseDist = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);
                    if (mouseDist < 200 * sizeScale && mouseDist > 30) {
                        // Gentle push away from mouse
                        const mouseForce = 0.5 / (mouseDist * 0.1 + 1);
                        fx -= (mouseDx / mouseDist) * mouseForce;
                        fy -= (mouseDy / mouseDist) * mouseForce;
                    }

                    // Apply forces with damping
                    nodeA.vx = (nodeA.vx + fx * 0.08) * damping;
                    nodeA.vy = (nodeA.vy + fy * 0.08) * damping;
                    nodeA.x += nodeA.vx;
                    nodeA.y += nodeA.vy;

                    totalMovement += Math.abs(nodeA.vx) + Math.abs(nodeA.vy);

                    // Keep within bounds with soft bounce
                    const padding = 60;
                    if (nodeA.x < padding) { nodeA.x = padding; nodeA.vx *= -0.5; }
                    if (nodeA.x > width - padding) { nodeA.x = width - padding; nodeA.vx *= -0.5; }
                    if (nodeA.y < padding) { nodeA.y = padding; nodeA.vy *= -0.5; }
                    if (nodeA.y > height - padding) { nodeA.y = height - padding; nodeA.vy *= -0.5; }

                    // Update base position for floating animation
                    nodeA.baseX = nodeA.x;
                    nodeA.baseY = nodeA.y;
                });

                // Never fully settle - keep subtle movement
                if (totalMovement < 0.5) {
                    settleTimer++;
                    if (settleTimer > 60) {
                        settled = true;
                    }
                } else {
                    settleTimer = 0;
                    settled = false;
                }
            }

            // ================================================
            // WEBGL SDF SPHERE RENDERER - PBR LIGHTING
            // ================================================
            let gl, glCanvas, sphereProgram, glReady = false;

            function initSphereGL() {
                glCanvas = document.createElement('canvas');
                glCanvas.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1;';
                container.insertBefore(glCanvas, container.firstChild);

                gl = glCanvas.getContext('webgl', { alpha: true, antialias: true, premultipliedAlpha: false });
                if (!gl) return false;

                const vert = `
                    attribute vec2 aPos;
                    attribute vec2 aCenter;
                    attribute float aRadius;
                    attribute vec3 aColor;
                    attribute float aAlpha;
                    attribute float aAppear;
                    attribute float aGlow;
                    attribute float aIndex;
                    attribute float aIsLight;
                    varying vec2 vUV;
                    varying vec2 vCenter;
                    varying float vRadius;
                    varying vec3 vColor;
                    varying float vAlpha;
                    varying float vAppear;
                    varying float vGlow;
                    varying float vIndex;
                    varying float vIsLight;
                    uniform vec2 uRes;
                    void main() {
                        vUV = aPos;
                        vCenter = aCenter;
                        vRadius = aRadius;
                        vColor = aColor;
                        vAlpha = aAlpha;
                        vAppear = aAppear;
                        vGlow = aGlow;
                        vIndex = aIndex;
                        vIsLight = aIsLight;
                        vec2 p = aCenter + aPos * aRadius * 3.0;
                        vec2 c = (p / uRes) * 2.0 - 1.0;
                        gl_Position = vec4(c.x, -c.y, 0.0, 1.0);
                    }
                `;

                const frag = `
                    precision highp float;
                    varying vec2 vUV;
                    varying vec2 vCenter;
                    varying float vRadius;
                    varying vec3 vColor;
                    varying float vAlpha;
                    varying float vAppear;
                    varying float vGlow;
                    varying float vIndex;
                    varying float vIsLight;
                    uniform vec2 uRes;
                    uniform vec2 uMouse;
                    uniform float uTime;
                    uniform vec2 uLight0;
                    uniform vec2 uLight1;
                    uniform vec2 uLight2;
                    uniform vec3 uLightColor0;
                    uniform vec3 uLightColor1;
                    uniform vec3 uLightColor2;

                    #define PI 3.14159265

                    void main() {
                        vec2 uv = vUV;
                        float d = length(uv);

                        // Index-based animation offset
                        float animOffset = vIndex * 0.5;
                        float t = uTime + animOffset;

                        // Appear animation
                        float ap = clamp(vAppear, 0.0, 1.0);
                        float scaledD = d / max(ap, 0.001);

                        // Soft outer fade to avoid hard edge artifacts
                        float outerFade = 1.0 - smoothstep(1.2, 1.45, scaledD);
                        if (outerFade < 0.001) discard;

                        // --- PLANET PARAMETERS ---
                        float planetRadius = 0.40;
                        float atmosphereThickness = 0.65;
                        float atmosphereOuter = planetRadius + atmosphereThickness;

                        // --- CHECK IF THIS IS A LIGHT SOURCE ---
                        if (vIsLight > 0.5) {
                            // Render as glowing emissive orb
                            float coreMask = 1.0 - smoothstep(0.0, 0.5, d);
                            float glowMask = 1.0 - smoothstep(0.0, 1.0, d);
                            float outerHalo = 0.03 / (d * d + 0.03);

                            // Pulsing animation
                            float pulse = sin(t * 2.0) * 0.5 + 0.5;
                            float breathe = 0.85 + pulse * 0.15;

                            // Emissive color (brighter than base)
                            vec3 emissive = vColor * 1.5;
                            vec3 col = vec3(0.0);

                            // Bright core
                            col += emissive * coreMask * 2.0 * breathe;

                            // Inner glow
                            col += emissive * glowMask * 0.8;

                            // Outer halo
                            col += emissive * outerHalo * 0.6;

                            // Hover boost
                            col += vColor * vGlow * 0.5;

                            // Tone mapping
                            col = col / (col + vec3(0.5));

                            float alpha = coreMask * 0.95 + glowMask * 0.5 + outerHalo * 0.4;
                            alpha = clamp(alpha, 0.0, 1.0) * outerFade;
                            alpha *= smoothstep(0.0, 0.5, ap) * vAlpha;

                            gl_FragColor = vec4(col, alpha);
                            return;
                        }

                        // --- PLANET COLOR VARIATION based on index ---
                        float varSeed = vIndex * 1.618;
                        vec3 planetColor = vColor;
                        // Hue shift
                        float hueShift = sin(varSeed) * 0.1;
                        planetColor.r += hueShift;
                        planetColor.g += hueShift;
                        planetColor.b -= hueShift;
                        // Saturation variation
                        float satVar = cos(varSeed * 2.3) * 0.5;
                        vec3 gray = vec3(dot(planetColor, vec3(0.299, 0.587, 0.114)));
                        planetColor = mix(planetColor, gray, .8);
                        // Brightness variation
                        planetColor *= 0.9 + sin(varSeed * 3.7) * 0.15;

                        // --- PLANET SURFACE ---
                        float planetMask = 1.0 - smoothstep(planetRadius - 0.0002, planetRadius, d);

                        // Sphere normal
                        float zSq = planetRadius * planetRadius - d * d;
                        float z = zSq > 0.0 ? sqrt(zSq) : 0.0;
                        vec3 N = d < planetRadius ? normalize(vec3(uv, z)) : vec3(0.0, 0.0, 1.0);
                        vec3 V = vec3(0.0, 0.0, 1.0);

                        // --- ACCUMULATE LIGHTING FROM ALL SOURCES ---
                        vec3 totalDiffuse = vec3(0.0);
                        vec3 totalSpecular = vec3(0.0);
                        float totalAttenuation = 0.0;

                        // Mouse light (white)
                        vec2 mouseOffset = (uMouse - vCenter);
                        vec3 mouseLightPos = vec3(mouseOffset / uRes.x * 4.0, 0.3);
                        vec3 mouseL = normalize(mouseLightPos);
                        float mouseDist = length(mouseLightPos);
                        float mouseAtten = 0.08 / (mouseDist * mouseDist + 0.01);
                        mouseAtten = min(mouseAtten, 2.0);

                        float mouseNdL = max(dot(N, mouseL), 0.0);
                        vec3 mouseH = normalize(mouseL + V);
                        float mouseNdH = max(dot(N, mouseH), 0.0);
                        totalDiffuse += vec3(1.0) * mouseNdL * mouseAtten;
                        totalSpecular += vec3(1.0) * pow(mouseNdH, 32.0) * mouseAtten;
                        totalAttenuation += mouseAtten;

                        // Point light 0 (Unity - orange)
                        vec2 light0Offset = (uLight0 - vCenter);
                        vec3 light0Pos = vec3(light0Offset / uRes.x * 3.0, 0.1);
                        vec3 L0 = normalize(light0Pos);
                        float dist0 = length(light0Pos);
                        float atten0 = 0.06 / (dist0 * dist0 + 0.02);
                        atten0 = min(atten0, 1.5);

                        float NdL0 = max(dot(N, L0), 0.0);
                        vec3 H0 = normalize(L0 + V);
                        float NdH0 = max(dot(N, H0), 0.0);
                        totalDiffuse += uLightColor0 * NdL0 * atten0;
                        totalSpecular += uLightColor0 * pow(NdH0, 32.0) * atten0;
                        totalAttenuation += atten0;

                        // Point light 1 (C# - purple)
                        vec2 light1Offset = (uLight1 - vCenter);
                        vec3 light1Pos = vec3(light1Offset / uRes.x * 3.0, 0.1);
                        vec3 L1 = normalize(light1Pos);
                        float dist1 = length(light1Pos);
                        float atten1 = 0.06 / (dist1 * dist1 + 0.02);
                        atten1 = min(atten1, 1.5);

                        float NdL1 = max(dot(N, L1), 0.0);
                        vec3 H1 = normalize(L1 + V);
                        float NdH1 = max(dot(N, H1), 0.0);
                        totalDiffuse += uLightColor1 * NdL1 * atten1;
                        totalSpecular += uLightColor1 * pow(NdH1, 32.0) * atten1;
                        totalAttenuation += atten1;

                        // Point light 2 (HLSL - cyan)
                        vec2 light2Offset = (uLight2 - vCenter);
                        vec3 light2Pos = vec3(light2Offset / uRes.x * 3.0, 0.1);
                        vec3 L2 = normalize(light2Pos);
                        float dist2 = length(light2Pos);
                        float atten2 = 0.06 / (dist2 * dist2 + 0.02);
                        atten2 = min(atten2, 1.5);

                        float NdL2 = max(dot(N, L2), 0.0);
                        vec3 H2 = normalize(L2 + V);
                        float NdH2 = max(dot(N, H2), 0.0);
                        totalDiffuse += uLightColor2 * NdL2 * atten2;
                        totalSpecular += uLightColor2 * pow(NdH2, 32.0) * atten2;
                        totalAttenuation += atten2;

                        // --- ATMOSPHERE ---
                        float atmosDist = d - planetRadius;
                        float atmosMask = smoothstep(atmosphereOuter, planetRadius, d);
                        float atmosDensity = atmosMask * (1.0 - planetMask);
                        vec3 atmosColor = planetColor * 1.2 + vec3(0.05, 0.08, 0.15);

                        float NdV = max(dot(N, V), 0.0);
                        float limbAngle = 1.0 - abs(dot(N, V));
                        float limbGlow = pow(limbAngle, 2.0) * atmosMask;

                        float ringDist = abs(d - planetRadius);
                        float atmosRing = exp(-ringDist * 8.0) * 0.6;

                        float outerGlow = 0.0;
                        if (d > planetRadius) {
                            float glowDist = d - planetRadius;
                            outerGlow = exp(-glowDist * 4.0) * 0.5;
                            outerGlow += 0.015 / (glowDist + 0.02);
                        }

                        // --- COMPOSE FINAL COLOR ---
                        vec3 col = vec3(0.0);
                        vec3 surfaceColor = planetColor * 0.85;

                        // Lit surface
                        col += surfaceColor * totalDiffuse * 1.5 * planetMask;
                        col += planetColor * totalSpecular * 0.3 * planetMask;

                        // Ambient for dark side
                        col += surfaceColor * 0.02 * planetMask;

                        // Atmosphere effects
                        col += atmosColor * limbGlow * totalAttenuation * 0.3 * planetMask;
                        col += planetColor * atmosRing * totalAttenuation * 0.2;
                        col += planetColor * outerGlow * totalAttenuation * 0.4;

                        // Fresnel
                        float fresnel = pow(1.0 - NdV, 4.0) * planetMask;
                        col += planetColor * fresnel * totalAttenuation * 0.2;

                        // Hover
                        col += planetColor * vGlow * (0.15 + fresnel * 0.3);

                        // Tone mapping
                        col = col / (col + vec3(0.7));
                        col = pow(col, vec3(0.95));

                        // Alpha
                        float alpha = 0.0;
                        alpha += planetMask * 0.98;
                        alpha += atmosDensity * 0.4;
                        alpha += atmosRing * 0.2;
                        alpha += outerGlow * 0.3;
                        alpha = clamp(alpha, 0.0, 1.0);
                        alpha *= outerFade;
                        alpha *= smoothstep(0.0, 0.5, ap);
                        alpha *= vAlpha;

                        gl_FragColor = vec4(col, alpha);
                    }
                `;

                function comp(s, t) {
                    const sh = gl.createShader(t);
                    gl.shaderSource(sh, s);
                    gl.compileShader(sh);
                    if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
                        console.error(gl.getShaderInfoLog(sh));
                        return null;
                    }
                    return sh;
                }

                const vs = comp(vert, gl.VERTEX_SHADER);
                const fs = comp(frag, gl.FRAGMENT_SHADER);
                if (!vs || !fs) return false;

                sphereProgram = gl.createProgram();
                gl.attachShader(sphereProgram, vs);
                gl.attachShader(sphereProgram, fs);
                gl.linkProgram(sphereProgram);

                if (!gl.getProgramParameter(sphereProgram, gl.LINK_STATUS)) {
                    console.error(gl.getProgramInfoLog(sphereProgram));
                    return false;
                }

                sphereProgram.aPos = gl.getAttribLocation(sphereProgram, 'aPos');
                sphereProgram.aCenter = gl.getAttribLocation(sphereProgram, 'aCenter');
                sphereProgram.aRadius = gl.getAttribLocation(sphereProgram, 'aRadius');
                sphereProgram.aColor = gl.getAttribLocation(sphereProgram, 'aColor');
                sphereProgram.aAlpha = gl.getAttribLocation(sphereProgram, 'aAlpha');
                sphereProgram.aAppear = gl.getAttribLocation(sphereProgram, 'aAppear');
                sphereProgram.aGlow = gl.getAttribLocation(sphereProgram, 'aGlow');
                sphereProgram.aIndex = gl.getAttribLocation(sphereProgram, 'aIndex');
                sphereProgram.aIsLight = gl.getAttribLocation(sphereProgram, 'aIsLight');
                sphereProgram.uRes = gl.getUniformLocation(sphereProgram, 'uRes');
                sphereProgram.uMouse = gl.getUniformLocation(sphereProgram, 'uMouse');
                sphereProgram.uTime = gl.getUniformLocation(sphereProgram, 'uTime');
                sphereProgram.uLight0 = gl.getUniformLocation(sphereProgram, 'uLight0');
                sphereProgram.uLight1 = gl.getUniformLocation(sphereProgram, 'uLight1');
                sphereProgram.uLight2 = gl.getUniformLocation(sphereProgram, 'uLight2');
                sphereProgram.uLightColor0 = gl.getUniformLocation(sphereProgram, 'uLightColor0');
                sphereProgram.uLightColor1 = gl.getUniformLocation(sphereProgram, 'uLightColor1');
                sphereProgram.uLightColor2 = gl.getUniformLocation(sphereProgram, 'uLightColor2');
                sphereProgram.buf = gl.createBuffer();

                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.clearColor(0, 0, 0, 0);

                glReady = true;
                return true;
            }

            function resizeSphereGL() {
                if (!glReady) return;
                glCanvas.width = width * (window.devicePixelRatio || 1);
                glCanvas.height = height * (window.devicePixelRatio || 1);
                gl.viewport(0, 0, glCanvas.width, glCanvas.height);
            }

            function hex2vec(h) {
                return [parseInt(h.slice(1,3),16)/255, parseInt(h.slice(3,5),16)/255, parseInt(h.slice(5,7),16)/255];
            }

            function renderSpheresGL(nodes, hovered, connected) {
                if (!glReady) return false;

                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(sphereProgram);
                gl.uniform2f(sphereProgram.uRes, width, height);
                gl.uniform2f(sphereProgram.uMouse, mouseX, mouseY);
                gl.uniform1f(sphereProgram.uTime, time);

                // Find light source positions and colors (Unity, C#, HLSL)
                const lightNodes = nodes.filter(n => n.isLight);
                const light0 = lightNodes[0] || { x: 0, y: 0, lightColor: '#ffaa33' };
                const light1 = lightNodes[1] || { x: 0, y: 0, lightColor: '#9b4dca' };
                const light2 = lightNodes[2] || { x: 0, y: 0, lightColor: '#33ddff' };
                gl.uniform2f(sphereProgram.uLight0, light0.x, light0.y);
                gl.uniform2f(sphereProgram.uLight1, light1.x, light1.y);
                gl.uniform2f(sphereProgram.uLight2, light2.x, light2.y);
                // Individual light colors
                const lc0 = hex2vec(light0.lightColor || '#ffaa33');
                const lc1 = hex2vec(light1.lightColor || '#9b4dca');
                const lc2 = hex2vec(light2.lightColor || '#33ddff');
                gl.uniform3f(sphereProgram.uLightColor0, lc0[0], lc0[1], lc0[2]);
                gl.uniform3f(sphereProgram.uLightColor1, lc1[0], lc1[1], lc1[2]);
                gl.uniform3f(sphereProgram.uLightColor2, lc2[0], lc2[1], lc2[2]);

                const v = [];
                const q = [[-1,-1],[1,-1],[1,1],[-1,-1],[1,1],[-1,1]];

                nodes.forEach((n, idx) => {
                    // Skip fully shrunk nodes
                    const shrink = n.shrinkProgress !== undefined ? n.shrinkProgress : 1;
                    if (shrink < 0.01) return;

                    let c;
                    // Light sources use their own lightColor, others use category color
                    if (n.isLight && n.lightColor) {
                        c = hex2vec(n.lightColor);
                    } else if (n.category === 'primary') {
                        c = hex2vec(colors.gold);
                    } else if (n.category === 'secondary') {
                        c = hex2vec(colors.teal);
                    } else {
                        c = hex2vec(colors.textMuted);
                    }

                    const g = n.glowIntensity || 0;
                    const p = Math.sin(time * n.pulseSpeed + n.pulsePhase);
                    // Apply shrink to radius
                    const baseR = n.size + p * 0.5 + g * 3;
                    const r = baseR * shrink;
                    const ap = globalFadeIn * shrink; // Use global fade in
                    const a = shrink * globalFadeIn; // Alpha also follows fade in
                    const nodeIndex = idx;
                    const isLight = n.isLight ? 1.0 : 0.0;

                    q.forEach(([qx,qy]) => {
                        v.push(qx, qy, n.x, n.y, r, c[0], c[1], c[2], a, ap, g, nodeIndex, isLight);
                    });
                });

                const d = new Float32Array(v);
                gl.bindBuffer(gl.ARRAY_BUFFER, sphereProgram.buf);
                gl.bufferData(gl.ARRAY_BUFFER, d, gl.DYNAMIC_DRAW);

                const st = 13 * 4; // 13 floats per vertex now
                gl.enableVertexAttribArray(sphereProgram.aPos);
                gl.vertexAttribPointer(sphereProgram.aPos, 2, gl.FLOAT, false, st, 0);
                gl.enableVertexAttribArray(sphereProgram.aCenter);
                gl.vertexAttribPointer(sphereProgram.aCenter, 2, gl.FLOAT, false, st, 8);
                gl.enableVertexAttribArray(sphereProgram.aRadius);
                gl.vertexAttribPointer(sphereProgram.aRadius, 1, gl.FLOAT, false, st, 16);
                gl.enableVertexAttribArray(sphereProgram.aColor);
                gl.vertexAttribPointer(sphereProgram.aColor, 3, gl.FLOAT, false, st, 20);
                gl.enableVertexAttribArray(sphereProgram.aAlpha);
                gl.vertexAttribPointer(sphereProgram.aAlpha, 1, gl.FLOAT, false, st, 32);
                gl.enableVertexAttribArray(sphereProgram.aAppear);
                gl.vertexAttribPointer(sphereProgram.aAppear, 1, gl.FLOAT, false, st, 36);
                gl.enableVertexAttribArray(sphereProgram.aGlow);
                gl.vertexAttribPointer(sphereProgram.aGlow, 1, gl.FLOAT, false, st, 40);
                gl.enableVertexAttribArray(sphereProgram.aIndex);
                gl.vertexAttribPointer(sphereProgram.aIndex, 1, gl.FLOAT, false, st, 44);
                gl.enableVertexAttribArray(sphereProgram.aIsLight);
                gl.vertexAttribPointer(sphereProgram.aIsLight, 1, gl.FLOAT, false, st, 48);

                // Draw based on actual vertex count (some nodes may be skipped)
                const vertexCount = v.length / 13;
                gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
                return true;
            }

            // Canvas 2D fallback
            function drawLitSphere(x, y, radius, baseColor, alpha, appearProgress, glow) {
                if (appearProgress < 0.01) return;
                const r = radius * appearProgress;
                if (r < 1) return;

                const cr = parseInt(baseColor.slice(1,3), 16);
                const cg = parseInt(baseColor.slice(3,5), 16);
                const cb = parseInt(baseColor.slice(5,7), 16);

                const lx = (mouseX - x) / (width || 1);
                const ly = (mouseY - y) / (height || 1);
                const ld = Math.sqrt(lx*lx + ly*ly) || 1;
                const hx = x - (lx/ld) * r * 0.35;
                const hy = y - (ly/ld) * r * 0.35;

                const grad = ctx.createRadialGradient(hx, hy, 0, x, y, r);
                grad.addColorStop(0, `rgba(${Math.min(255,cr+70)},${Math.min(255,cg+70)},${Math.min(255,cb+70)},${alpha})`);
                grad.addColorStop(0.35, `rgba(${cr},${cg},${cb},${alpha})`);
                grad.addColorStop(0.8, `rgba(${cr*0.55|0},${cg*0.55|0},${cb*0.55|0},${alpha})`);
                grad.addColorStop(1, `rgba(${cr*0.25|0},${cg*0.25|0},${cb*0.25|0},${alpha*0.85})`);

                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = grad;
                ctx.fill();

                // Specular
                const sg = ctx.createRadialGradient(hx, hy, 0, hx, hy, r*0.28);
                sg.addColorStop(0, `rgba(255,255,255,${alpha*0.75})`);
                sg.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.beginPath();
                ctx.arc(hx, hy, r*0.28, 0, Math.PI * 2);
                ctx.fillStyle = sg;
                ctx.fill();

                // Rim
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255,255,255,${alpha*0.18 + (glow||0)*0.35})`;
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }

            // Track time for glow delays
            let lastHoveredNode = null;
            let hoverStartTime = 0;

            function draw() {
                ctx.clearRect(0, 0, width, height);
                time += 0.016;

                const connectedToHovered = hoveredNode ? getConnectedNodes(hoveredNode) : new Set();

                // Reset glow delay timer when hover changes
                if (hoveredNode !== lastHoveredNode) {
                    hoverStartTime = time;
                    lastHoveredNode = hoveredNode;
                }

                const timeSinceHover = time - hoverStartTime;

                // Update glow intensities and shrink with smooth transitions
                nodes.forEach(node => {
                    const isHovered = node === hoveredNode;
                    const isConnected = connectedToHovered.has(node.id);

                    // Set target glow intensity and shrink
                    if (isHovered) {
                        node.targetGlowIntensity = 1;
                        node.glowDelay = 0;
                        node.targetShrink = 1;
                    } else if (isConnected) {
                        node.targetGlowIntensity = 0.6;
                        node.glowDelay = 0.15;
                        node.targetShrink = 1;
                    } else if (hoveredNode) {
                        // Not connected to hovered - shrink away
                        node.targetGlowIntensity = 0;
                        node.glowDelay = 0;
                        node.targetShrink = 0;
                    } else {
                        // No hover - show all
                        node.targetGlowIntensity = 0;
                        node.glowDelay = 0;
                        node.targetShrink = 1;
                    }

                    // Smoothly interpolate glow intensity with delay
                    const effectiveTime = Math.max(0, timeSinceHover - node.glowDelay);
                    if (effectiveTime > 0 || node.targetGlowIntensity === 0) {
                        const lerpSpeed = node.targetGlowIntensity > node.glowIntensity ? 0.08 : 0.12;
                        node.glowIntensity += (node.targetGlowIntensity - node.glowIntensity) * lerpSpeed;
                    }

                    // Smoothly interpolate shrink
                    const shrinkSpeed = node.targetShrink > node.shrinkProgress ? 0.12 : 0.08;
                    node.shrinkProgress += (node.targetShrink - node.shrinkProgress) * shrinkSpeed;

                    // Clamp very small values
                    if (node.glowIntensity < 0.01) node.glowIntensity = 0;
                    if (node.shrinkProgress < 0.01) node.shrinkProgress = 0;
                    if (node.shrinkProgress > 0.99) node.shrinkProgress = 1;
                });

                // Apply floating animation - always active for interesting movement
                nodes.forEach(node => {
                    if (node === dragNode) return;

                    // Primary float (figure-8 pattern)
                    const floatX = Math.sin(time * node.floatSpeed + node.floatPhase) * node.floatRadius;
                    const floatY = Math.cos(time * node.floatSpeed * 0.7 + node.floatPhase) * node.floatRadius * 0.8;

                    // Secondary wobble (adds complexity)
                    const wobbleX = Math.sin(time * node.floatSpeed2 + node.floatPhase * 2.0) * node.floatRadius2;
                    const wobbleY = Math.cos(time * node.floatSpeed2 * 1.3 + node.floatPhase * 2.0) * node.floatRadius2;

                    // Micro orbit around base position
                    node.orbitAngle += node.orbitSpeed * 0.016;
                    const orbitX = Math.cos(node.orbitAngle) * node.orbitRadius;
                    const orbitY = Math.sin(node.orbitAngle) * node.orbitRadius * 0.6;

                    // Combine all movements
                    if (settled) {
                        node.x = node.baseX + floatX + wobbleX + orbitX;
                        node.y = node.baseY + floatY + wobbleY + orbitY;
                    } else {
                        // During simulation, just add subtle float
                        node.x += (floatX + wobbleX) * 0.02;
                        node.y += (floatY + wobbleY) * 0.02;
                    }

                    node.rotation += node.rotationSpeed;
                });

                // Draw connections with gradient and mouse light
                connections.forEach(([a, b]) => {
                    const nodeA = nodes.find(n => n.id === a);
                    const nodeB = nodes.find(n => n.id === b);
                    if (!nodeA || !nodeB) return;

                    const isHighlighted = hoveredNode &&
                        (hoveredNode.id === a || hoveredNode.id === b);

                    // Get shrink progress of both nodes to fade connection
                    const shrinkA = nodeA.shrinkProgress !== undefined ? nodeA.shrinkProgress : 1;
                    const shrinkB = nodeB.shrinkProgress !== undefined ? nodeB.shrinkProgress : 1;
                    const connectionFade = Math.min(shrinkA, shrinkB);

                    // Skip fully faded connections
                    if (connectionFade < 0.01) return;

                    if (isHighlighted) {
                        // Highlighted connection - warm gold gradient
                        const gradient = ctx.createLinearGradient(nodeA.x, nodeA.y, nodeB.x, nodeB.y);
                        const alpha = 0.8 * connectionFade;
                        gradient.addColorStop(0, `rgba(255, 170, 50, ${alpha})`);
                        gradient.addColorStop(0.5, `rgba(255, 220, 100, ${alpha})`);
                        gradient.addColorStop(1, `rgba(255, 170, 50, ${alpha})`);
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 2;
                    } else {
                        // Hide non-highlighted connections when hovering
                        if (hoveredNode) return;
                        // Default - extremely subtle
                        const baseAlpha = 0.035 * connectionFade;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${baseAlpha})`;
                        ctx.lineWidth = 0.5;
                    }

                    ctx.beginPath();
                    ctx.moveTo(nodeA.x, nodeA.y);
                    ctx.lineTo(nodeB.x, nodeB.y);
                    ctx.stroke();
                });

                // Draw nodes with WebGL PBR shader (falls back to Canvas 2D)
                if (!renderSpheresGL(nodes, hoveredNode, connectedToHovered)) {
                    // Canvas 2D fallback
                    nodes.forEach(node => {
                        const shrink = node.shrinkProgress !== undefined ? node.shrinkProgress : 1;
                        if (shrink < 0.01 || globalFadeIn < 0.01) return;

                        const pulse = Math.sin(time * node.pulseSpeed + node.pulsePhase);
                        const sizeBoost = node.glowIntensity * 3;
                        const displaySize = (node.size + pulse * 0.5 + sizeBoost) * shrink;

                        let baseColor;
                        if (node.category === 'primary') baseColor = colors.gold;
                        else if (node.category === 'secondary') baseColor = colors.teal;
                        else baseColor = colors.textMuted;

                        const alpha = shrink * globalFadeIn;
                        drawLitSphere(node.x, node.y, displaySize, baseColor, alpha, globalFadeIn * shrink, node.glowIntensity);
                    });
                }

                // Draw labels
                nodes.forEach(node => {
                    const isHovered = node === hoveredNode;
                    const isConnected = connectedToHovered.has(node.id);
                    const shrink = node.shrinkProgress !== undefined ? node.shrinkProgress : 1;

                    // Skip label if shrunk or not yet faded in
                    if (shrink < 0.1) return;
                    if (globalFadeIn < 0.5) return;

                    const labelAlpha = Math.min(1, (globalFadeIn - 0.5) * 2) * shrink;
                    const pulse = Math.sin(time * node.pulseSpeed + node.pulsePhase);
                    const sizeBoost = node.glowIntensity * 3;
                    const displaySize = (node.size + pulse * 0.5 + sizeBoost) * shrink;

                    // Label with background - smooth font weight transition, scaled for screen size
                    const labelOffset = 12 * sizeScale + 6;
                    const labelY = node.y + displaySize + labelOffset;
                    const fontWeight = node.glowIntensity > 0.5 ? '600' : '500';
                    const baseFontSize = 8 + 2 * sizeScale;
                    const fontSize = (baseFontSize + node.glowIntensity) * (0.7 + shrink * 0.3);
                    ctx.font = `${fontWeight} ${fontSize}px "JetBrains Mono", monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    const textWidth = ctx.measureText(node.label).width;
                    const paddingX = 3 * sizeScale + 1;
                    const paddingY = 5 * sizeScale + 2;

                    ctx.globalAlpha = labelAlpha;

                    // Label background
                    ctx.fillStyle = `rgba(21, 29, 38, ${0.8 * shrink})`;
                    ctx.beginPath();
                    ctx.roundRect(node.x - textWidth / 2 - paddingX, labelY - paddingY, textWidth + paddingX * 2, paddingY * 2, 3);
                    ctx.fill();

                    // Label text
                    ctx.fillStyle = colors.textPrimary;
                    ctx.fillText(node.label, node.x, labelY);

                    ctx.globalAlpha = 1;
                });

                // Draw tooltip connector line after nodes
                drawTooltipConnector();
            }

            function animate() {
                simulate();
                draw();
                updateShowcase();
                requestAnimationFrame(animate);
            }

            // Event handlers
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                dragNode = getNodeAt(mouseX, mouseY);
                if (dragNode) {
                    isDragging = true;
                    settled = false;
                    container.style.cursor = 'grabbing';
                    // If we're starting to drag a node that has tooltip, set it as target
                    if (hoveredNode === dragNode && !tooltipTarget) {
                        tooltipTarget = dragNode;
                        generateTooltipPosition(dragNode);
                    }
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;

                if (isDragging && dragNode) {
                    dragNode.x = mouseX;
                    dragNode.y = mouseY;
                    dragNode.baseX = mouseX;
                    dragNode.baseY = mouseY;
                    dragNode.vx = 0;
                    dragNode.vy = 0;
                    settled = false;
                    settleTimer = 0;
                    // Update tooltip position to follow the dragged node
                    if (tooltipTarget === dragNode) {
                        updateTooltipPositionForDrag(dragNode);
                    }
                } else {
                    hoveredNode = getNodeAt(mouseX, mouseY);
                    container.style.cursor = hoveredNode ? 'pointer' : 'grab';
                    updateTooltip(hoveredNode);
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                dragNode = null;
                container.style.cursor = hoveredNode ? 'pointer' : 'grab';
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                dragNode = null;
                hoveredNode = null;
                container.style.cursor = 'grab';
                updateTooltip(null);
            });

            // Touch support
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                mouseX = touch.clientX - rect.left;
                mouseY = touch.clientY - rect.top;
                dragNode = getNodeAt(mouseX, mouseY);
                if (dragNode) {
                    isDragging = true;
                    settled = false;
                    // Show tooltip for touched node
                    tooltipTarget = dragNode;
                    generateTooltipPosition(dragNode);
                    updateTooltip(dragNode);
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDragging || !dragNode) return;
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                dragNode.x = touch.clientX - rect.left;
                dragNode.y = touch.clientY - rect.top;
                dragNode.baseX = dragNode.x;
                dragNode.baseY = dragNode.y;
                dragNode.vx = 0;
                dragNode.vy = 0;
                settled = false;
                // Update tooltip position to follow the dragged node
                if (tooltipTarget === dragNode) {
                    updateTooltipPositionForDrag(dragNode);
                }
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                isDragging = false;
                dragNode = null;
            });

            // Initialize
            window.addEventListener('resize', resize);

            // Initialize WebGL sphere renderer
            initSphereGL();

            resize();

            // Initialize showcase timer (start after a short delay)
            lastShowcaseTime = performance.now();

            // Reset fade in when returning to tab
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    time = 0;
                    globalFadeIn = 0;
                    startupPhase = true;
                    lastShowcaseTime = performance.now();
                    // Hide any active tooltip/showcase
                    tooltip.classList.remove('visible');
                    tooltipTarget = null;
                    showcaseActive = false;
                    showcaseNode = null;
                }
            });

            animate();
        })();

        // Counting animation for stats
        (function() {
            const stats = document.querySelectorAll('.stat-number[data-target]');

            stats.forEach((stat, index) => {
                const target = parseInt(stat.dataset.target);
                const suffix = stat.dataset.suffix || '';
                let current = 0;
                const duration = 1500; // ms
                const startDelay = 600 + index * 200; // Stagger start
                const stepTime = duration / target;

                setTimeout(() => {
                    const interval = setInterval(() => {
                        current++;
                        stat.textContent = current + (current === target ? suffix : '');

                        if (current >= target) {
                            clearInterval(interval);
                        }
                    }, stepTime);
                }, startDelay);
            });
        })();

        // Staggered reveal animation for clients and projects
        (function() {
            const clientCards = document.querySelectorAll('.client-card');
            const testimonialCards = document.querySelectorAll('.testimonial-card');
            const projectCards = document.querySelectorAll('.project-card');

            // Stagger client cards animation
            clientCards.forEach((card, i) => {
                card.style.animationDelay = `${0.6 + i * 0.08}s`;
            });

            // Stagger testimonial cards animation
            testimonialCards.forEach((card, i) => {
                card.style.animationDelay = `${0.6 + i * 0.15}s`;
            });

            // Stagger project cards animation
            projectCards.forEach((card, i) => {
                card.style.animationDelay = `${0.6 + i * 0.12}s`;
            });
        })();

        // Portfolio carousel functionality
        (function() {
            const slides = document.querySelectorAll('.portfolio-slide');
            const thumbs = document.querySelectorAll('.portfolio-thumb');
            const prevBtn = document.querySelector('.portfolio-nav.prev');
            const nextBtn = document.querySelector('.portfolio-nav.next');
            const currentSpan = document.getElementById('portfolio-current');
            const thumbnailsContainer = document.getElementById('portfolio-thumbnails');

            let currentIndex = 0;
            const totalSlides = slides.length;

            function goToSlide(index) {
                // Handle wrap-around
                if (index < 0) index = totalSlides - 1;
                if (index >= totalSlides) index = 0;

                // Update slides
                slides.forEach((slide, i) => {
                    slide.classList.toggle('active', i === index);
                });

                // Update thumbnails
                thumbs.forEach((thumb, i) => {
                    thumb.classList.toggle('active', i === index);
                });

                // Scroll thumbnail into view
                if (thumbs[index] && thumbnailsContainer) {
                    const thumb = thumbs[index];
                    const containerRect = thumbnailsContainer.getBoundingClientRect();
                    const thumbRect = thumb.getBoundingClientRect();

                    if (thumbRect.left < containerRect.left || thumbRect.right > containerRect.right) {
                        thumb.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
                    }
                }

                // Update counter
                if (currentSpan) currentSpan.textContent = index + 1;

                currentIndex = index;
            }

            // Navigation buttons
            if (prevBtn) prevBtn.addEventListener('click', () => goToSlide(currentIndex - 1));
            if (nextBtn) nextBtn.addEventListener('click', () => goToSlide(currentIndex + 1));

            // Thumbnail clicks
            thumbs.forEach((thumb, i) => {
                thumb.addEventListener('click', () => goToSlide(i));
            });

            // Keyboard navigation when portfolio panel is visible
            document.addEventListener('keydown', (e) => {
                const portfolioPanel = document.getElementById('panel-portfolio');
                if (!portfolioPanel || !portfolioPanel.classList.contains('active')) return;

                if (e.key === 'ArrowLeft') goToSlide(currentIndex - 1);
                if (e.key === 'ArrowRight') goToSlide(currentIndex + 1);
            });

            // Touch swipe support
            let touchStartX = 0;
            let touchEndX = 0;
            const portfolioMain = document.querySelector('.portfolio-main');

            if (portfolioMain) {
                portfolioMain.addEventListener('touchstart', (e) => {
                    touchStartX = e.changedTouches[0].screenX;
                }, { passive: true });

                portfolioMain.addEventListener('touchend', (e) => {
                    touchEndX = e.changedTouches[0].screenX;
                    const diff = touchStartX - touchEndX;
                    if (Math.abs(diff) > 50) {
                        if (diff > 0) goToSlide(currentIndex + 1);
                        else goToSlide(currentIndex - 1);
                    }
                }, { passive: true });
            }
        })();

        // Typewriter effect with typos
        (function() {
            const container = document.getElementById('typewriter-container');
            const typingIndicator = document.getElementById('typing-indicator');
            const dots = typingIndicator ? typingIndicator.querySelectorAll('.typing-dots span') : [];
            if (!container) return;

            const fullText = [
                { text: 'I run ', highlight: false },
                { text: 'Zylaris Ltd', highlight: true },
                { text: ', a specialized consultancy delivering high-performance graphics solutions for games, VR, and immersive installations. From ', highlight: false },
                { text: 'GPU-based light baking', highlight: true },
                { text: ' using SDFs to ', highlight: false },
                { text: '16K projection-mapped environments', highlight: true },
                { text: ', I help studios push the boundaries of real-time rendering across mobile, desktop, VR, and web platforms. I\'ve shipped graphics systems for studios including ', highlight: false },
                { text: 'Nexus, Ubisoft, 22cans, and The Sandbox', highlight: true },
                { text: '.', highlight: false }
            ];

            // Define typos: [position in full string, wrong char, correct char]
            const typos = [
                { pos: 15, wrong: 'x', correct: 'c' },      // "speciaxized" -> "specialized"
                { pos: 78, wrong: 'f', correct: 'g' },      // "fames" -> "games"
                { pos: 142, wrong: 'b', correct: 'p' },     // "berformance" -> "performance"
                { pos: 245, wrong: 'r', correct: 't' },     // "srudios" -> "studios"
            ];

            let cursor = document.createElement('span');
            cursor.className = 'typewriter-cursor';
            container.appendChild(cursor);

            let globalPos = 0;
            let segmentIndex = 0;
            let charIndex = 0;
            let currentSpan = null;
            let typoQueue = [...typos].sort((a, b) => a.pos - b.pos);
            let isDeleting = false;
            let deleteCount = 0;
            let typoChar = null;
            let dotIndex = 0;
            let dotInterval = null;

            // Animate dots: 0 -> 1 -> 2 -> 3 -> 0 -> 1 -> 2 -> 3
            function animateDots() {
                if (!dots.length) return;

                // Reset all dots
                dots.forEach((dot, i) => {
                    dot.classList.toggle('visible', i < dotIndex);
                });

                dotIndex++;
                if (dotIndex > 3) dotIndex = 0;
            }

            // Start dot animation
            dotInterval = setInterval(animateDots, 300);

            function getBaseDelay() {
                return 12 + Math.random() * 18; // Faster: was 25-60, now 12-30
            }

            function finishTyping() {
                cursor.classList.add('hidden');
                if (typingIndicator) {
                    typingIndicator.classList.add('hidden');
                }
                if (dotInterval) {
                    clearInterval(dotInterval);
                }
            }

            function type() {
                if (segmentIndex >= fullText.length) {
                    finishTyping();
                    return;
                }

                const segment = fullText[segmentIndex];

                // Create span for new segment
                if (!currentSpan) {
                    currentSpan = document.createElement('span');
                    if (segment.highlight) {
                        currentSpan.className = 'highlight-text';
                    }
                    container.insertBefore(currentSpan, cursor);
                }

                // Check for typo at current position
                const currentTypo = typoQueue[0];
                if (currentTypo && globalPos === currentTypo.pos && !isDeleting && !typoChar) {
                    // Type wrong character
                    typoChar = document.createElement('span');
                    typoChar.className = 'typo-char';
                    typoChar.textContent = currentTypo.wrong;
                    currentSpan.appendChild(typoChar);
                    globalPos++;
                    charIndex++;

                    // Schedule delete after brief pause
                    setTimeout(() => {
                        isDeleting = true;
                        deleteCount = 1;
                        setTimeout(type, 80 + Math.random() * 50);
                    }, 120 + Math.random() * 80);
                    return;
                }

                // Handle deleting typo
                if (isDeleting && deleteCount > 0) {
                    if (typoChar) {
                        typoChar.remove();
                        typoChar = null;
                    }
                    globalPos--;
                    charIndex--;
                    deleteCount--;
                    isDeleting = false;
                    typoQueue.shift(); // Remove processed typo
                    setTimeout(type, 50);
                    return;
                }

                // Normal typing
                if (charIndex < segment.text.length) {
                    currentSpan.textContent += segment.text[charIndex];
                    charIndex++;
                    globalPos++;

                    // Variable delay - slower for punctuation
                    let delay = getBaseDelay();
                    const char = segment.text[charIndex - 1];
                    if (['.', ',', '!', '?'].includes(char)) {
                        delay += 80 + Math.random() * 60;
                    } else if (char === ' ') {
                        delay += Math.random() * 15;
                    }

                    setTimeout(type, delay);
                } else {
                    // Move to next segment
                    segmentIndex++;
                    charIndex = 0;
                    currentSpan = null;
                    setTimeout(type, getBaseDelay());
                }
            }

            // Start after a delay
            setTimeout(type, 500);
        })();

        // Project List Scroll Handler
        (function() {
            const wrapper = document.getElementById('project-list-wrapper');
            const list = document.getElementById('project-list');
            const hint = wrapper ? wrapper.querySelector('.scroll-hint') : null;
            if (!wrapper || !list) return;

            function updateScrollState() {
                const scrollPos = list.scrollTop;
                const maxScroll = list.scrollHeight - list.clientHeight;

                // Remove all scroll state classes
                wrapper.classList.remove('scrolled-top', 'scrolled-middle', 'scrolled-end');

                if (scrollPos <= 10) {
                    // At top - no top fade, show bottom fade
                    wrapper.classList.add('scrolled-top');
                    if (hint) hint.style.opacity = '0.7';
                } else if (scrollPos >= maxScroll - 10) {
                    // At bottom - show top fade, no bottom fade
                    wrapper.classList.add('scrolled-end');
                    if (hint) hint.style.opacity = '0';
                } else {
                    // In middle - show both fades
                    wrapper.classList.add('scrolled-middle');
                    if (hint) hint.style.opacity = '0.5';
                }
            }

            list.addEventListener('scroll', updateScrollState);
            updateScrollState(); // Initial state
        })();

        // Tabbed Carousel
        (function() {
            const tabs = document.querySelectorAll('.carousel-tab');
            const panels = document.querySelectorAll('.carousel-panel');

            if (!tabs.length || !panels.length) return;

            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const panelId = tab.dataset.panel;

                    // Update active tab
                    tabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    // Update active panel with animation
                    panels.forEach(panel => {
                        if (panel.id === `panel-${panelId}`) {
                            panel.classList.add('active');
                            // Re-trigger animations for elements in this panel
                            triggerPanelAnimations(panel);
                        } else {
                            panel.classList.remove('active');
                        }
                    });

                    // Reinitialize skill graph canvas if switching to skills panel
                    if (panelId === 'skills') {
                        const canvas = document.getElementById('skill-graph-canvas');
                        if (canvas) {
                            // Trigger resize to reinitialize
                            window.dispatchEvent(new Event('resize'));
                        }
                    }
                });
            });

            function triggerPanelAnimations(panel) {
                // Reset and re-trigger animations for client cards
                const clientCards = panel.querySelectorAll('.client-card');
                clientCards.forEach((card, i) => {
                    card.style.animation = 'none';
                    card.offsetHeight; // Trigger reflow
                    card.style.animation = '';
                    card.style.animationDelay = `${i * 0.08}s`;
                });

                // Reset and re-trigger animations for testimonial cards
                const testimonialCards = panel.querySelectorAll('.testimonial-card');
                testimonialCards.forEach((card, i) => {
                    card.style.animation = 'none';
                    card.offsetHeight; // Trigger reflow
                    card.style.animation = '';
                    card.style.animationDelay = `${i * 0.15}s`;
                });

                // Reset and re-trigger animations for project cards
                const projectCards = panel.querySelectorAll('.project-card');
                projectCards.forEach((card, i) => {
                    card.style.animation = 'none';
                    card.offsetHeight; // Trigger reflow
                    card.style.animation = '';
                    card.style.animationDelay = `${i * 0.12}s`;
                });
            }
        })();

        // ============================================
        // ANIMATED FAVICON - Breathing Dot
        // ============================================
        (function() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const link = document.getElementById('favicon');

            let time = 0;
            const gold = '#e8b923';

            function draw() {
                ctx.clearRect(0, 0, 32, 32);

                const cx = 16;
                const cy = 16;

                // Smooth breathing animation
                const pulse = Math.sin(time) * 0.2 + 0.8;
                const radius = 9 * pulse;

                // Soft glow
                const gradient = ctx.createRadialGradient(cx, cy, radius * 0.5, cx, cy, radius + 3);
                gradient.addColorStop(0, gold);
                gradient.addColorStop(0.7, 'rgba(232, 185, 35, 0.4)');
                gradient.addColorStop(1, 'transparent');

                ctx.beginPath();
                ctx.arc(cx, cy, radius + 3, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Core dot
                ctx.beginPath();
                ctx.arc(cx, cy, radius * 0.7, 0, Math.PI * 2);
                ctx.fillStyle = gold;
                ctx.fill();

                link.href = canvas.toDataURL('image/png');
            }

            function animate() {
                time += 0.04;
                draw();
                requestAnimationFrame(animate);
            }

            animate();
        })();

        // ============================================
        // FPS PERFORMANCE COUNTER
        // ============================================
        (function() {
            const fpsBadge = document.getElementById('fps-badge');
            const fpsValue = document.getElementById('fps-value');

            if (!fpsBadge || !fpsValue) return;

            let frameCount = 0;
            let lastTime = performance.now();
            let fps = 60;

            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                const elapsed = currentTime - lastTime;

                // Update every 500ms for smoother display
                if (elapsed >= 500) {
                    fps = Math.round((frameCount * 1000) / elapsed);
                    frameCount = 0;
                    lastTime = currentTime;

                    // Update display
                    fpsValue.textContent = fps;

                    // Update badge class based on performance
                    fpsBadge.classList.remove('good', 'warn', 'bad');
                    if (fps >= 50) {
                        fpsBadge.classList.add('good');
                    } else if (fps >= 30) {
                        fpsBadge.classList.add('warn');
                    } else {
                        fpsBadge.classList.add('bad');
                    }
                }

                requestAnimationFrame(updateFPS);
            }

            // Start FPS monitoring
            requestAnimationFrame(updateFPS);
        })();
    </script>
</body>
</html>