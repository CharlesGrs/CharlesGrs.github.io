<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depth Map Particles | Three.js</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
        }

        #canvas {
            display: block;
        }

        .controls {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            z-index: 100;
        }

        .control-btn {
            padding: 0.75rem 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .control-btn.active {
            background: rgba(232, 185, 35, 0.3);
            border-color: #e8b923;
        }

        .info {
            position: fixed;
            top: 2rem;
            left: 2rem;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
            z-index: 100;
        }

        .info h1 {
            font-size: 1.2rem;
            color: #e8b923;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e8b923;
            font-size: 1rem;
            z-index: 200;
        }

        .hidden {
            display: none;
        }

        .settings-panel {
            position: fixed;
            top: 2rem;
            right: 2rem;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 1.5rem;
            z-index: 100;
            min-width: 280px;
            backdrop-filter: blur(10px);
        }

        .settings-panel h2 {
            color: #e8b923;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            font-weight: 500;
        }

        .slider-group {
            margin-bottom: 1rem;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.75rem;
            margin-bottom: 0.3rem;
        }

        .slider-group label span {
            color: #2dd4bf;
            font-family: monospace;
        }

        .slider-group input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #e8b923;
            cursor: pointer;
        }

        .slider-group input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #e8b923;
            cursor: pointer;
            border: none;
        }

        .rebuild-btn {
            width: 100%;
            padding: 0.75rem;
            background: linear-gradient(135deg, #e8b923 0%, #c49a1a 100%);
            border: none;
            border-radius: 6px;
            color: #000;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            margin-top: 0.5rem;
            transition: all 0.3s ease;
        }

        .rebuild-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(232, 185, 35, 0.4);
        }

        .settings-panel hr {
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div class="info">
        <h1>Depth Map Particles</h1>
        <p>Drag to rotate | Scroll to zoom</p>
    </div>

    <div class="controls">
        <button class="control-btn active" data-mode="points">Points</button>
        <button class="control-btn" data-mode="wave">Wave</button>
        <button class="control-btn" data-mode="explode">Explode</button>
        <button class="control-btn" data-mode="spiral">Spiral</button>
    </div>

    <div class="loading" id="loading">Loading depth map...</div>

    <!-- Settings Panel -->
    <div class="settings-panel">
        <h2>Depth Map Settings</h2>

        <div class="slider-group">
            <label>Depth Scale <span id="depthScaleVal">50</span></label>
            <input type="range" id="depthScale" min="0" max="200" value="50">
        </div>

        <div class="slider-group">
            <label>XY Scale <span id="xyScaleVal">0.18</span></label>
            <input type="range" id="xyScale" min="5" max="50" value="18">
        </div>

        <div class="slider-group">
            <label>Particle Count <span id="particleCountVal">120k</span></label>
            <input type="range" id="particleCount" min="10" max="300" value="120">
        </div>

        <div class="slider-group">
            <label>Particle Size <span id="particleSizeVal">1.0</span></label>
            <input type="range" id="particleSize" min="1" max="50" value="10">
        </div>

        <hr>

        <div class="slider-group">
            <label>Brightness Threshold <span id="thresholdVal">3</span></label>
            <input type="range" id="threshold" min="0" max="100" value="3">
        </div>

        <div class="slider-group">
            <label>Depth Offset <span id="depthOffsetVal">0</span></label>
            <input type="range" id="depthOffset" min="-100" max="100" value="0">
        </div>

        <div class="slider-group">
            <label>Depth Power (curve) <span id="depthPowerVal">1.0</span></label>
            <input type="range" id="depthPower" min="1" max="30" value="10">
        </div>

        <div class="slider-group">
            <label>Invert Depth <span id="invertVal">No</span></label>
            <input type="range" id="invertDepth" min="0" max="1" value="0">
        </div>

        <button class="rebuild-btn" id="rebuildBtn">Rebuild Particles</button>
    </div>

    <!-- Add your depth map image here -->
    <img id="depthmap" src="depthmap.png" style="display: none;" crossorigin="anonymous">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Depth Map Particle System
        (function() {
            const canvas = document.getElementById('canvas');
            const loading = document.getElementById('loading');

            // Renderer
            const renderer = new THREE.WebGLRenderer({
                canvas,
                antialias: true,
                alpha: true
            });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1);

            // Scene & Camera
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 300;

            // Mouse controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            // Start with a side angle to clearly show 3D depth
            let targetRotation = { x: 0.15, y: -0.8 };
            let currentRotation = { x: 0.15, y: -0.8 };
            let zoom = 200;
            let targetZoom = 200;

            // Animation mode
            let currentMode = 'points';
            let modeTransition = 0;

            // Particle system variables
            let particles = null;
            let particlePositions = null;
            let originalPositions = null;
            let particleColors = null;
            let particleSizes = null;
            let particleCount = 0;

            // Store image data for rebuilds
            let storedImageData = null;
            let storedWidth = 0;
            let storedHeight = 0;

            // Settings (controlled by sliders)
            const settings = {
                depthScale: 50,
                xyScale: 0.18,
                targetParticles: 120000,
                particleSize: 1.0,
                threshold: 3,
                depthOffset: 0,
                depthPower: 1.0,
                invertDepth: false
            };

            // Slider elements
            const sliders = {
                depthScale: document.getElementById('depthScale'),
                xyScale: document.getElementById('xyScale'),
                particleCount: document.getElementById('particleCount'),
                particleSize: document.getElementById('particleSize'),
                threshold: document.getElementById('threshold'),
                depthOffset: document.getElementById('depthOffset'),
                depthPower: document.getElementById('depthPower'),
                invertDepth: document.getElementById('invertDepth')
            };

            // Value displays
            const displays = {
                depthScale: document.getElementById('depthScaleVal'),
                xyScale: document.getElementById('xyScaleVal'),
                particleCount: document.getElementById('particleCountVal'),
                particleSize: document.getElementById('particleSizeVal'),
                threshold: document.getElementById('thresholdVal'),
                depthOffset: document.getElementById('depthOffsetVal'),
                depthPower: document.getElementById('depthPowerVal'),
                invertDepth: document.getElementById('invertVal')
            };

            // Read settings from sliders
            function readSettings() {
                settings.depthScale = parseFloat(sliders.depthScale.value);
                settings.xyScale = parseFloat(sliders.xyScale.value) / 100;
                settings.targetParticles = parseFloat(sliders.particleCount.value) * 1000;
                settings.particleSize = parseFloat(sliders.particleSize.value) / 10;
                settings.threshold = parseFloat(sliders.threshold.value);
                settings.depthOffset = parseFloat(sliders.depthOffset.value);
                settings.depthPower = parseFloat(sliders.depthPower.value) / 10;
                settings.invertDepth = sliders.invertDepth.value === '1';
            }

            // Update displays when sliders change
            function updateDisplays() {
                displays.depthScale.textContent = sliders.depthScale.value;
                displays.xyScale.textContent = (sliders.xyScale.value / 100).toFixed(2);
                displays.particleCount.textContent = sliders.particleCount.value + 'k';
                displays.particleSize.textContent = (sliders.particleSize.value / 10).toFixed(1);
                displays.threshold.textContent = sliders.threshold.value;
                displays.depthOffset.textContent = sliders.depthOffset.value;
                displays.depthPower.textContent = (sliders.depthPower.value / 10).toFixed(1);
                displays.invertDepth.textContent = sliders.invertDepth.value === '1' ? 'Yes' : 'No';
            }

            // Add listeners to all sliders
            Object.values(sliders).forEach(slider => {
                slider.addEventListener('input', updateDisplays);
            });

            // Rebuild particles function
            function rebuildParticles() {
                // Read current slider values
                readSettings();

                console.log('Rebuilding with settings:', settings);

                // Remove old particles
                if (particles) {
                    scene.remove(particles);
                    if (particles.geometry) particles.geometry.dispose();
                    if (particles.material) particles.material.dispose();
                    particles = null;
                }

                // Rebuild using stored image data (pass null to use stored)
                if (storedImageData) {
                    processDepthMap(null);
                } else {
                    // Try to load from image element
                    const img = document.getElementById('depthmap');
                    if (img && img.naturalWidth > 0) {
                        processDepthMap(img);
                    } else {
                        console.log('No image data, using procedural fallback');
                        createProceduralDepthMap();
                    }
                }
            }

            // Rebuild button
            document.getElementById('rebuildBtn').addEventListener('click', rebuildParticles);

            // Load depth map from the provided image
            function loadDepthMap() {
                // Read initial settings from sliders
                readSettings();
                updateDisplays();

                const img = document.getElementById('depthmap');

                // Function to try loading the image
                function tryLoadImage() {
                    try {
                        const testCanvas = document.createElement('canvas');
                        const testCtx = testCanvas.getContext('2d');
                        testCanvas.width = img.naturalWidth || 100;
                        testCanvas.height = img.naturalHeight || 100;
                        testCtx.drawImage(img, 0, 0);
                        // This will throw if CORS blocked
                        testCtx.getImageData(0, 0, 1, 1);
                        console.log('Image loaded successfully, dimensions:', img.naturalWidth, 'x', img.naturalHeight);
                        processDepthMap(img);
                    } catch (e) {
                        console.warn('Cannot read image data (CORS or file:// protocol). Using procedural fallback.', e.message);
                        console.log('TIP: Run a local server (e.g., "npx serve" or "python -m http.server") to load images properly.');
                        createProceduralDepthMap();
                    }
                }

                // Wait for image to load if not already
                if (!img.complete) {
                    img.onload = tryLoadImage;
                    img.onerror = () => {
                        console.log('Could not load depthmap.png, using procedural fallback');
                        createProceduralDepthMap();
                    };
                    return;
                }

                if (img.naturalWidth === 0) {
                    console.log('Image failed to load, using procedural fallback');
                    createProceduralDepthMap();
                    return;
                }

                tryLoadImage();
            }

            function processDepthMap(img) {
                let data, width, height;

                // Use stored data if available, otherwise extract from image
                if (storedImageData && !img) {
                    data = storedImageData;
                    width = storedWidth;
                    height = storedHeight;
                } else if (img) {
                    const imgCanvas = document.createElement('canvas');
                    const ctx = imgCanvas.getContext('2d');

                    // Use full resolution for better detail
                    width = img.naturalWidth;
                    height = img.naturalHeight;

                    imgCanvas.width = width;
                    imgCanvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);

                    const imageData = ctx.getImageData(0, 0, width, height);
                    data = imageData.data;

                    // Store for rebuilds
                    storedImageData = data;
                    storedWidth = width;
                    storedHeight = height;
                } else {
                    console.error('No image data available');
                    return;
                }

                // Helper to get brightness at x,y
                function getBrightness(x, y) {
                    if (x < 0 || x >= width || y < 0 || y >= height) return 0;
                    const i = (Math.floor(y) * width + Math.floor(x)) * 4;
                    return (data[i] + data[i + 1] + data[i + 2]) / 3;
                }

                // Sample particles from depth map
                const positions = [];
                const colors = [];
                const sizes = [];

                // Use settings from sliders
                const scaleXY = settings.xyScale;
                const depthScale = settings.depthScale;
                const targetParticles = settings.targetParticles;
                const threshold = settings.threshold;
                const depthOffset = settings.depthOffset;
                const depthPower = settings.depthPower;
                const invertDepth = settings.invertDepth;
                const baseSize = settings.particleSize;

                // Sample with some randomness for organic distribution
                const area = width * height;
                const skipChance = 1 - (targetParticles / area);

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // Random sampling for even distribution
                        if (Math.random() < skipChance) continue;

                        const brightness = getBrightness(x, y);

                        // Only create particles above threshold
                        if (brightness > threshold) {
                            let normalizedBrightness = brightness / 255;

                            // Invert if needed
                            if (invertDepth) {
                                normalizedBrightness = 1 - normalizedBrightness;
                            }

                            // Apply power curve for depth mapping
                            const curvedBrightness = Math.pow(normalizedBrightness, depthPower);

                            // X, Y: screen position centered at origin
                            const px = (x - width / 2) * scaleXY;
                            const py = -(y - height / 2) * scaleXY;

                            // Z: depth from brightness with offset
                            const pz = curvedBrightness * depthScale + depthOffset;

                            // Small jitter for organic feel
                            const jitter = 0.3;
                            const jx = (Math.random() - 0.5) * jitter;
                            const jy = (Math.random() - 0.5) * jitter;

                            positions.push(px + jx, py + jy, pz);

                            // Color based on original brightness (not curved)
                            const gold = { r: 0.91, g: 0.73, b: 0.14 };
                            const teal = { r: 0.18, g: 0.83, b: 0.75 };
                            const white = { r: 1, g: 1, b: 1 };

                            // Use original normalized brightness for coloring
                            const colorBrightness = invertDepth ? (1 - normalizedBrightness) : normalizedBrightness;

                            let color;
                            if (colorBrightness > 0.75) {
                                const t = (colorBrightness - 0.75) / 0.25;
                                color = {
                                    r: gold.r + (white.r - gold.r) * t,
                                    g: gold.g + (white.g - gold.g) * t,
                                    b: gold.b + (white.b - gold.b) * t
                                };
                            } else if (colorBrightness > 0.35) {
                                const t = (colorBrightness - 0.35) / 0.4;
                                color = {
                                    r: teal.r + (gold.r - teal.r) * t,
                                    g: teal.g + (gold.g - teal.g) * t,
                                    b: teal.b + (gold.b - teal.b) * t
                                };
                            } else {
                                const t = colorBrightness / 0.35;
                                color = {
                                    r: teal.r * t * 0.5,
                                    g: teal.g * t * 0.5,
                                    b: teal.b * t * 0.5
                                };
                            }

                            colors.push(color.r, color.g, color.b);

                            // Size based on settings and brightness
                            sizes.push(baseSize * (0.5 + colorBrightness * 0.8));
                        }
                    }
                }

                particleCount = positions.length / 3;
                console.log(`Created ${particleCount} particles from depth map`);

                createParticleSystem(positions, colors, sizes);
                loading.classList.add('hidden');
            }

            function createProceduralDepthMap() {
                // Generate particles that approximate a face depth map
                const positions = [];
                const colors = [];
                const sizes = [];

                // Use settings from sliders
                const scaleXY = settings.xyScale;
                const depthScale = settings.depthScale;
                const targetParticles = settings.targetParticles;
                const depthOffset = settings.depthOffset;
                const depthPower = settings.depthPower;
                const invertDepth = settings.invertDepth;
                const baseSize = settings.particleSize;

                const width = 800;
                const height = 1000;

                // Generate depth value for a position (simulates a face depth map)
                function getDepth(x, y) {
                    // Normalize to -1 to 1
                    const nx = x / (width * 0.5);
                    const ny = y / (height * 0.5);

                    // Check if in silhouette first
                    if (!isInSilhouette(x, y, width, height)) return 0;

                    let depth = 0;

                    // Base face shape - ellipsoid
                    const faceY = ny + 0.15; // Face center offset
                    const faceDist = Math.sqrt(nx * nx * 1.2 + faceY * faceY);
                    if (faceDist < 0.6) {
                        depth = Math.sqrt(Math.max(0, 1 - faceDist * faceDist * 2.8)) * 0.9;
                    }

                    // Nose - prominent ridge
                    const noseX = Math.abs(nx);
                    const noseY = ny + 0.05;
                    if (noseX < 0.08 && noseY > -0.15 && noseY < 0.2) {
                        const noseDepth = (1 - noseX / 0.08) * (1 - Math.abs(noseY) / 0.2) * 0.4;
                        depth += noseDepth;
                    }

                    // Forehead bulge
                    if (ny > 0.1 && ny < 0.45 && Math.abs(nx) < 0.35) {
                        const foreheadDepth = Math.cos(nx * 3) * 0.15 * (1 - (ny - 0.1) / 0.35);
                        depth += Math.max(0, foreheadDepth);
                    }

                    // Cheeks
                    const cheekDist = Math.sqrt((Math.abs(nx) - 0.2) ** 2 + (ny + 0.05) ** 2);
                    if (cheekDist < 0.2) {
                        depth += (1 - cheekDist / 0.2) * 0.15;
                    }

                    // Eye sockets (indentations)
                    const eyeY = ny + 0.15;
                    for (const eyeX of [-0.15, 0.15]) {
                        const eyeDist = Math.sqrt((nx - eyeX) ** 2 + eyeY ** 2);
                        if (eyeDist < 0.08) {
                            depth -= (1 - eyeDist / 0.08) * 0.1;
                        }
                    }

                    // Neck/chest - lower depth
                    if (ny < -0.35) {
                        const neckFactor = Math.min(1, (-0.35 - ny) / 0.3);
                        depth *= (1 - neckFactor * 0.5);
                    }

                    // Shoulders
                    if (ny < -0.5) {
                        const shoulderWidth = 0.4 + ((-0.5 - ny) / 0.3) * 0.3;
                        if (Math.abs(nx) < shoulderWidth) {
                            depth = Math.max(depth, 0.3 * (1 - Math.abs(nx) / shoulderWidth));
                        }
                    }

                    return Math.max(0, Math.min(1, depth));
                }

                // Sample particles
                const sampleArea = width * height;
                const skipChance = 1 - (targetParticles / sampleArea);

                for (let py = -height/2; py < height/2; py += 2) {
                    for (let px = -width/2; px < width/2; px += 2) {
                        if (Math.random() < skipChance) continue;

                        let depth = getDepth(px, py);
                        if (depth <= 0.02) continue;

                        // Apply invert
                        if (invertDepth) depth = 1 - depth;

                        // Apply power curve
                        const curvedDepth = Math.pow(depth, depthPower);

                        // Position
                        const x = px * scaleXY * 0.25;
                        const y = -py * scaleXY * 0.25;
                        const z = curvedDepth * depthScale + depthOffset;

                        // Jitter
                        const jx = (Math.random() - 0.5) * 0.3;
                        const jy = (Math.random() - 0.5) * 0.3;

                        positions.push(x + jx, y + jy, z);

                        // Color based on depth
                        const colorDepth = invertDepth ? (1 - depth) : depth;
                        const gold = { r: 0.91, g: 0.73, b: 0.14 };
                        const teal = { r: 0.18, g: 0.83, b: 0.75 };
                        const white = { r: 1, g: 1, b: 1 };

                        let color;
                        if (colorDepth > 0.7) {
                            const t = (colorDepth - 0.7) / 0.3;
                            color = {
                                r: gold.r + (white.r - gold.r) * t,
                                g: gold.g + (white.g - gold.g) * t,
                                b: gold.b + (white.b - gold.b) * t
                            };
                        } else if (colorDepth > 0.3) {
                            const t = (colorDepth - 0.3) / 0.4;
                            color = {
                                r: teal.r + (gold.r - teal.r) * t,
                                g: teal.g + (gold.g - teal.g) * t,
                                b: teal.b + (gold.b - teal.b) * t
                            };
                        } else {
                            const t = colorDepth / 0.3;
                            color = {
                                r: teal.r * t * 0.5,
                                g: teal.g * t * 0.5,
                                b: teal.b * t * 0.5
                            };
                        }

                        colors.push(color.r, color.g, color.b);
                        sizes.push(baseSize * (0.5 + colorDepth * 0.8));
                    }
                }

                particleCount = positions.length / 3;
                console.log(`Created ${particleCount} procedural particles`);

                createParticleSystem(positions, colors, sizes);
                loading.classList.add('hidden');
            }

            function isInSilhouette(x, y, width, height) {
                // Approximate the silhouette from the depth map
                // Head region (top ellipse)
                const headCenterY = height * 0.25;
                const headRadiusX = width * 0.22;
                const headRadiusY = height * 0.18;

                // Check head with some hair irregularity
                const headDist = Math.pow(x / headRadiusX, 2) + Math.pow((y - headCenterY) / headRadiusY, 2);
                const hairNoise = Math.sin(Math.atan2(y - headCenterY, x) * 8) * 0.15;

                if (headDist < 1 + hairNoise && y > 0) {
                    return true;
                }

                // Hair on top (more irregular)
                if (y > headCenterY + headRadiusY * 0.3) {
                    const hairWidth = headRadiusX * (1.2 + Math.sin(y * 0.1) * 0.3);
                    if (Math.abs(x) < hairWidth && y < height * 0.5) {
                        return Math.random() > 0.3; // Some randomness for hair texture
                    }
                }

                // Neck
                const neckTop = headCenterY - headRadiusY * 0.8;
                const neckBottom = -height * 0.1;
                const neckWidth = width * 0.1;

                if (y < neckTop && y > neckBottom && Math.abs(x) < neckWidth) {
                    return true;
                }

                // Shoulders and upper body
                const shoulderY = -height * 0.1;
                const shoulderWidth = width * 0.35;

                if (y < shoulderY && y > -height * 0.5) {
                    // Trapezoid shape for shoulders/body
                    const bodyProgress = (shoulderY - y) / (height * 0.4);
                    const currentWidth = neckWidth + (shoulderWidth - neckWidth) * Math.min(bodyProgress * 2, 1);

                    if (Math.abs(x) < currentWidth) {
                        return true;
                    }
                }

                return false;
            }

            function createParticleSystem(positions, colors, sizes) {
                const geometry = new THREE.BufferGeometry();

                particlePositions = new Float32Array(positions);
                originalPositions = new Float32Array(positions);
                particleColors = new Float32Array(colors);
                particleSizes = new Float32Array(sizes);

                geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));

                // Custom shader material for particles
                const vertexShader = `
                    attribute float size;
                    varying vec3 vColor;
                    varying float vSize;

                    void main() {
                        vColor = color;
                        vSize = size;

                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (250.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `;

                const fragmentShader = `
                    varying vec3 vColor;
                    varying float vSize;

                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));

                        // Soft circular particle
                        float alpha = 1.0 - smoothstep(0.35, 0.5, dist);

                        // Glow effect
                        float glow = exp(-dist * 4.0) * 0.5;

                        vec3 finalColor = vColor + glow * 0.3;

                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `;

                const material = new THREE.ShaderMaterial({
                    vertexShader,
                    fragmentShader,
                    transparent: true,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                particles = new THREE.Points(geometry, material);
                scene.add(particles);
            }

            function createDefaultParticles() {
                // Fallback: create a simple particle field
                const positions = [];
                const colors = [];
                const sizes = [];

                for (let i = 0; i < 50000; i++) {
                    positions.push(
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 100
                    );

                    const brightness = Math.random();
                    colors.push(
                        0.91 * brightness,
                        0.73 * brightness,
                        0.14 + 0.61 * brightness
                    );

                    sizes.push(1.0 + Math.random() * 2.0);
                }

                particleCount = positions.length / 3;
                createParticleSystem(positions, colors, sizes);
            }

            // Mouse event handlers
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    targetRotation.y += deltaX * 0.005;
                    targetRotation.x += deltaY * 0.005;

                    // Clamp vertical rotation
                    targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotation.x));

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
            });

            // Touch events for mobile
            canvas.addEventListener('touchstart', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            });

            canvas.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    const deltaX = e.touches[0].clientX - previousMousePosition.x;
                    const deltaY = e.touches[0].clientY - previousMousePosition.y;

                    targetRotation.y += deltaX * 0.005;
                    targetRotation.x += deltaY * 0.005;
                    targetRotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotation.x));

                    previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
            });

            canvas.addEventListener('touchend', () => {
                isDragging = false;
            });

            // Zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                targetZoom += e.deltaY * 0.5;
                targetZoom = Math.max(100, Math.min(600, targetZoom));
            });

            // Mode buttons
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.control-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentMode = btn.dataset.mode;
                    modeTransition = 0;
                });
            });

            // Animation
            let time = 0;

            function animate() {
                requestAnimationFrame(animate);
                time += 0.016;
                modeTransition = Math.min(modeTransition + 0.02, 1);

                // Smooth rotation
                currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
                currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

                // Smooth zoom
                zoom += (targetZoom - zoom) * 0.05;
                camera.position.z = zoom;

                // Auto-rotate when not dragging
                if (!isDragging) {
                    targetRotation.y += 0.002;
                }

                // Update particle positions based on mode
                if (particles && originalPositions) {
                    const positions = particles.geometry.attributes.position.array;

                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;
                        const ox = originalPositions[i3];
                        const oy = originalPositions[i3 + 1];
                        const oz = originalPositions[i3 + 2];

                        let tx = ox, ty = oy, tz = oz;

                        switch (currentMode) {
                            case 'points':
                                // Original positions
                                break;

                            case 'wave':
                                // Wave animation
                                const waveX = Math.sin(time * 2 + oy * 0.05) * 10;
                                const waveZ = Math.cos(time * 2 + ox * 0.05) * 10;
                                tx = ox + waveX;
                                tz = oz + waveZ;
                                break;

                            case 'explode':
                                // Explode outward
                                const dist = Math.sqrt(ox * ox + oy * oy + oz * oz);
                                const explodeFactor = 1 + Math.sin(time) * 0.5;
                                const norm = dist > 0 ? 1 / dist : 0;
                                tx = ox + ox * norm * 30 * explodeFactor * modeTransition;
                                ty = oy + oy * norm * 30 * explodeFactor * modeTransition;
                                tz = oz + oz * norm * 30 * explodeFactor * modeTransition;
                                break;

                            case 'spiral':
                                // Spiral around Y axis
                                const angle = time + i * 0.0001;
                                const radius = Math.sqrt(ox * ox + oz * oz);
                                const spiralFactor = modeTransition;
                                tx = ox * Math.cos(angle * spiralFactor) - oz * Math.sin(angle * spiralFactor);
                                tz = ox * Math.sin(angle * spiralFactor) + oz * Math.cos(angle * spiralFactor);
                                ty = oy + Math.sin(time * 2 + i * 0.001) * 5 * spiralFactor;
                                break;
                        }

                        // Interpolate to target
                        positions[i3] += (tx - positions[i3]) * 0.1;
                        positions[i3 + 1] += (ty - positions[i3 + 1]) * 0.1;
                        positions[i3 + 2] += (tz - positions[i3 + 2]) * 0.1;
                    }

                    particles.geometry.attributes.position.needsUpdate = true;

                    // Apply rotation to particle system
                    particles.rotation.x = currentRotation.x;
                    particles.rotation.y = currentRotation.y;
                }

                renderer.render(scene, camera);
            }

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Start
            loadDepthMap();
            animate();
        })();
    </script>
</body>
</html>
